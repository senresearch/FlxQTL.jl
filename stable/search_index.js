var documenterSearchIndex = {"docs":
[{"location":"functions/#Functions-and-Types","page":"Types and Functions","title":"Functions and Types","text":"","category":"section"},{"location":"functions/","page":"Types and Functions","title":"Types and Functions","text":"CurrentModule = FlxQTL","category":"page"},{"location":"functions/#Flexible-Multivariate-Linear-Mixed-Models-(flxMLMM)","page":"Types and Functions","title":"Flexible Multivariate Linear Mixed Models (flxMLMM)","text":"","category":"section"},{"location":"functions/","page":"Types and Functions","title":"Types and Functions","text":"Modules = [FlxQTL, flxMLMM, EcmNestrv]","category":"page"},{"location":"functions/#FlxQTL.FlxQTL","page":"Types and Functions","title":"FlxQTL.FlxQTL","text":"FlxQTL\n\nflexible Multivariate Linear Mixed Model based QTL analysis tools for structured multiple traits.\n\n\n\n\n\n","category":"module"},{"location":"functions/#FlxQTL.flxMLMM","page":"Types and Functions","title":"FlxQTL.flxMLMM","text":"flxMLMM\n\nA module designed for fitting a Multivariate Linear Mixed Model run by Nesterov's Accelerated Gradient  with restarting scheme incorporated with Expectation Conditional Maximization.\n\nThe model:\n\nY=XBZ+R+E, where E(vec(Y))= (Z otimes X)vec(B),  var(vec(Y))= tau^2 K_G otimes K_C + I_n otimes Sigma\n\n\n\n\n\n","category":"module"},{"location":"functions/#FlxQTL.flxMLMM.K2Eig","page":"Types and Functions","title":"FlxQTL.flxMLMM.K2Eig","text":"  K2Eig(Kg,Kc::Array{Float64,2},LOCO::Bool=false)\n\nReturns a two pairs of eigenvectors and eigenvalues for genetic and climatic relatedness matrices.\n\nArguments\n\nKg : A matrix of a genetic kinship, or 3-d array of that if LOCO sets to be true.\nKc : A matrix of a climatic relatedness.\nLOCO : Boolean. Default is false (no LOCO). (Leave One Chromosome Out). LOCO is only connected to the genetic kinship (Kg).\n\nOutput\n\nTg : A matrix of eigenvectors for Kg, or 3-d array of eigenvectors if LOCO sets to be true.\nλg : A vector of eigenvalues for Kg, or matrix of eigenvalues if LOCO sets to be true.\nTc : A matrix of eigenvectors for Kc.\nλc : A vector of eigenvalues for Kc\n\nSee K2eig.\n\nExamples\n\nFor a genetic kinship calculated under LOCO (3-d array of kinship),\n\n Tg,λg,Tc,λc = K2Eig(Kg,Kc,true)\n\n\nproduces a 3-d array of Tg, matrices of λg, Tc, and a vector of λc.\n\n\n\n\n\n","category":"function"},{"location":"functions/#FlxQTL.flxMLMM.K2eig","page":"Types and Functions","title":"FlxQTL.flxMLMM.K2eig","text":"   K2eig(K,LOCO::Bool=false)\n\nReturns eigenvectors and eigenvalues of a (genetic, climatic) relatedness, or 3-d array of these of a genetic relatedness if LOCO is true.\n\nArguments\n\nK : A matrix of (genetic or climatic) relatedness (Default).  3-d array of genetic relatedness (LOCO sets to be true.)\nLOCO : Boolean. Default is false (no LOCO). (Leave One Chromosome Out).\n\nOutput\n\nT : A matrix of eigenvectors, or 3-d array of eigenvectors if LOCO sets to be true.\nλ : A vector of eigenvalues, or matrix of eigenvalues if LOCO sets to be true.\n\nSee also K2Eig.\n\nExamples\n\nFor a (climatic) relatedness, or genetic relatedness for LOCO =false,\n\n T, λ = K2eig(K)\n\n\nproduces a matrix of T and a vector of λ.\n\nFor a genetic kinship calculated under LOCO (3-d array of kinship),\n\n T, λ = K2eig(K,true)\n\n\nproduces a 3-d array of T and a matrix of λ.\n\n\n\n\n\n","category":"function"},{"location":"functions/#FlxQTL.flxMLMM.envScan","page":"Types and Functions","title":"FlxQTL.flxMLMM.envScan","text":"  envScan(Midx::Array{Int64,1},cross::Int64,Tg,Tc::Array{Float64,2},Λg,λc::Array{Float64,1},\n    Y0::Array{Float64,2},XX::Markers,Z0::Array{Float64,2},LOCO::Bool=false;\n            Xnul::Array{Float64,2}=ones(1,size(Y0,2)),itol=1e-4,tol0=1e-3,tol::Float64=1e-4,ρ=0.001)\n\nImplement environment scan conditional on a genetic marker of interest (QTL).  Each of q trait covariate data is scanned (regressed) given a major QTL selected from genome scan, geneScan to obtain LOD scores.\n\nArguments\n\nMidx : A vector of genetic marker indices (major QTL) selected based on LOD scores from geneScan.\ncross : An integer indicating the number of alleles or genotypes. Ex. 2 for RIF, 4 for four-way cross, 8 for HS mouse (allele probabilities), etc.         This value is related to degree of freedom when doing genome scan.\nTg : A n x n matrix of eigenvectors from K2eig, or K2Eig.      Returns 3d-array of eigenvectors as many as Chromosomes if LOCO is true.\nTc : A m x m matrix of eigenvectors from climatic relatedness matrix.\nΛg : A n x 1 vector of eigenvalues from kinship. Returns a matrix of eigenvalues if LOCO is true.\nλc : A m x 1 vector of eigenvalues from climatic relatedness matrix. Use ones(m) for no climatic information added.\nY0 : A m x n matrix of response variables, i.e. m traits (or environments) by n individuals (or lines). For univariate phenotypes, use square brackets in arguement.       i.e. Y0[1,:] (a vector) ->Y[[1],:] (a matrix) .\nXX : A type of Markers.\nZ0 :  A m x q matrix of low-dimensional trait covariate data for environment scan, i.e. minimum or maximum monthly temperature data, monthly photoperiod data, etc.\nLOCO : Boolean. Default is false (no LOCO). Runs genome scan using LOCO (Leave One Chromosome Out).\n\nKeyword Arguments\n\nXnul :  A matrix of covariates. Default is intercepts (1's).  Unless plugging in particular covariates, just leave as it is.\nitol :  A tolerance controlling ECM (Expectation Conditional Maximization) under H0: no QTL. Default is 1e-3.\ntol0 :  A tolerance controlling ECM under H1: existence of QTL. Default is 1e-3.\ntol : A tolerance of controlling Nesterov Acceleration Gradient method under both H0 and H1. Default is 1e-4.\nρ : A tunning parameter controlling tau^2. Default is 0.001.\n\n!!! Note\n\nWhen some LOD scores return negative values, reduce tolerences for ECM to tol0 = 1e-4. It works in most cases. If not,   can reduce both tol0 and tol to 1e-4 or further.\n\nOutput\n\nLODs : A vector of LOD scores by envrionment scan when including each major QTL.\nB : A 3-d array of B (fixed effects) matrices under H1: existence of an environment factor (covariate)        conditional on a major QTL.\nest0 : A type of EcmNestrv.Approx including parameter estimates under H0: no environment factor          conditional on a major QTL.\n\n\n\n\n\n","category":"function"},{"location":"functions/#FlxQTL.flxMLMM.gene2Scan","page":"Types and Functions","title":"FlxQTL.flxMLMM.gene2Scan","text":"gene2Scan(cross::Int64,Tg,Tc::Array{Float64,2},Λg,λc::Array{Float64,1},Y::Array{Float64,2},\n         XX::Markers,Z::Array{Float64,2},LOCO::Bool=false;ρ=0.001,Xnul::Array{Float64,2}=ones(1,size(Y,2)), \n         df_prior=m+1,Prior::Matrix{Float64}=cov(Y,dims=2)*5,itol=1e-4,tol0=1e-3,tol::Float64=1e-4)\ngene2Scan(cross::Int64,Tg,Λg,Y::Array{Float64,2},XX::Markers,Z::Array{Float64,2},LOCO::Bool=false;\n           Xnul::Array{Float64,2}=ones(1,size(Y,2)),df_prior=m+1,Prior::Matrix{Float64}=cov(Y,dims=2)*5,\n           itol=1e-3,tol0=1e-3,tol::Float64=1e-4,ρ=0.001)\ngene2Scan(cross::Int64,Tg,Λg,Y::Array{Float64,2},XX::Markers,LOCO::Bool=false;Xnul::Array{Float64,2}=ones(1,size(Y,2)),\n           df_prior=m+1,Prior::Matrix{Float64}=cov(Y,dims=2)*5,itol=1e-4,tol0=1e-3,tol::Float64=1e-4,ρ=0.001)\n\nImplement 2d-genome scan with/without LOCO (Leave One Chromosome Out). Note that the second gene2Scan includes getKc for      precomputing Kc– no need of precomputing and doing eigen-decomposition to Kc separately.  The last gene2Scan is run by a conventional MLMM (no Z, i.e. Z=I):\n\nvec(Y) sim MVN((Z otimes X)vec(B) (or XBZ)  K otimes Sigma_1 +I otimes Sigma_2)\n\nwhere K is a genetic kinship, Sigma_1 Sigma_2 are covariance matrices for random and error terms, respectively.  Z can be replaced with an identity matrix.\n\nArguments\n\ncross : An integer indicating the number of alleles or genotypes. Ex. 2 for RIF, 4 for four-way cross, 8 for HS mouse (allele probabilities), etc.         This value is related to degree of freedom when doing genome scan.\nTg : A n x n matrix of eigenvectors from K2eig, or K2Eig.      Returns 3d-array of eigenvectors as many as Chromosomes if LOCO is true.\nTc : A m x m matrix of eigenvectors from climatic relatedness matrix.\nΛg : A n x 1 vector of eigenvalues from kinship. Returns a matrix of eigenvalues if LOCO is true.\nλc : A m x 1 vector of eigenvalues from climatic relatedness matrix. Use ones(m) for no climatic information added.\nY : A m x n matrix of response variables, i.e. m traits (or environments) by n individuals (or lines). For univariate phenotypes, use square brackets in arguement.       i.e. Y0[1,:] (a vector) -> Y[[1],:] (a matrix) .\nXX : A type of Markers.\nZ :  An optional m x q matrix of low-dimensional phenotypic covariates, i.e. contrasts, basis functions (fourier, wavelet, polynomials, B-splines, etc.).       To use the identity matrix just as the conventional MLMM, simply type diagm(ones(m)).\nLOCO : Boolean. Default is false (no LOCO). Runs genome scan using LOCO (Leave One Chromosome Out).\n\nKeyword Arguments\n\nXnul :  A matrix of covariates. Default is intercepts (1's).  Unless adding covariates, just leave as it is.  See geneScan.\nPrior: A positive definite scale matrix, Psi, of prior Inverse-Wishart distributon, i.e. Sigma sim W^-1_m (Psi nu_0).           A large scaled covariance matrix (a weakly informative prior) is default.\ndf_prior: degrees of freedom, nu_0 for Inverse-Wishart distributon.  m+1 (weakly informative) is default.\nitol :  A tolerance controlling ECM (Expectation Conditional Maximization) under H0: no QTL. Default is 1e-3.\ntol0 :  A tolerance controlling ECM under H1: existence of QTL. Default is 1e-3.\ntol : A tolerance of controlling Nesterov Acceleration Gradient method under both H0 and H1. Default is 1e-4.\nρ : A tunning parameter controlling tau^2. Default is 0.001.\n\n!!! Note\n\nWhen some LOD scores return negative values, reduce tolerences for ECM to tol0 = 1e-4. It works in most cases. If not,   can reduce both tol0 and tol to 1e-4 or further.  2D scan is usually computationally heavy and takes much time especially for     large data with high-dimensional traits, i.e. large m and n.  This will be worse when the conventional LMM  is chosen.\n\nOutput\n\nLODs : LOD scores. Can change to - log_10P using lod2logP.\nest0 : A type of EcmNestrv.Approx including parameter estimates under H0: no QTL.\n\n\n\n\n\n","category":"function"},{"location":"functions/#FlxQTL.flxMLMM.geneScan","page":"Types and Functions","title":"FlxQTL.flxMLMM.geneScan","text":"geneScan(cross::Int64,Tg,Tc::Array{Float64,2},Λg,λc::Array{Float64,1},Y::Array{Float64,2},XX::Markers,Z::Array{Float64,2},\n         LOCO::Bool=false;m=size(Y,1),tdata::Bool=false,LogP::Bool=false,Xnul::Array{Float64,2}=ones(1,size(Y,2)),df_prior=m+1,\n            Prior::Matrix{Float64}=cov(Y,dims=2)*5,itol=1e-3,tol0=1e-3,tol::Float64=1e-4,ρ=0.001)\ngeneScan(cross::Int64,Tg::Union{Array{Float64,3},Array{Float64,2}},Tc::Array{Float64,2},Λg::Union{Array{Float64,2},Array{Float64,1}},\n         λc::Array{Float64,1},Y::Array{Float64,2},XX::Markers,LOCO::Bool=false;m=size(Y,1),LogP::Bool=false,Xnul::Array{Float64,2}=ones(1,size(Y,2)),df_prior=m+1,\n    Prior::Matrix{Float64}=cov(Y,dims=2)*5,itol=1e-3,tol0=1e-3,tol::Float64=1e-4,ρ=0.001)\ngeneScan(cross::Int64,Tg,Λg,Y::Array{Float64,2},XX::Markers,LOCO::Bool=false;m=size(Y,1),Xnul::Array{Float64,2}=ones(1,size(Y,2)),\n            df_prior=m+1,Prior::Matrix{Float64}=cov(Y,dims=2)*5,tdata::Bool=false,LogP::Bool=false,\n           itol=1e-3,tol0=1e-3,tol::Float64=1e-4,ρ=0.001)\ngene1Scan(cross::Int64,Tg,Λg,Y::Array{Float64,2},XX::Markers,Z::Array{Float64,2},LOCO::Bool=false;m=size(Y,1),\n           Xnul::Array{Float64,2}=ones(1,size(Y,2)),df_prior=m+1,Prior::Matrix{Float64}=cov(Y,dims=2)*5,\n             tdata::Bool=false,LogP::Bool=false,itol=1e-3,tol0=1e-3,tol::Float64=1e-4,ρ=0.001)\n\nImplement 1d-genome scan with/without LOCO (Leave One Chromosome Out).  Note that gene1Scan includes getKc for      precomputing Kc– no need of precomputing and doing eigen-decomposition to Kc separately.  The third geneScan() is based on a conventional MLMM:\n\nvec(Y) sim MVN((Z otimes X)vec(B) (or XBZ)  K otimes Sigma_1 +I otimes Sigma_2)\n\nwhere K is a genetic kinship, Sigma_1 Sigma_2 are covariance matrices for random and error terms, respectively.  Z can be replaced with an identity matrix.\n\nArguments\n\ncross : An integer indicating the number of alleles or genotypes. Ex. 2 for RIF, 4 for four-way cross, 8 for HS mouse (allele probabilities), etc.         This value is related to degree of freedom when doing genome scan.\nTg : A n x n matrix of eigenvectors from K2eig, or K2Eig.      Returns 3d-array of eigenvectors as many as Chromosomes if LOCO is true.\nTc : A m x m matrix of eigenvectors from climatic relatedness matrix.\nΛg : A n x 1 vector of eigenvalues from kinship. Returns a matrix of eigenvalues if LOCO is true.\nλc : A m x 1 vector of eigenvalues from climatic relatedness matrix. Use ones(m) for no climatic information added.\nY : A m x n matrix of response variables, i.e. m traits (or environments) by n individuals (or lines). For univariate phenotypes, use square brackets in arguement.       i.e. Y0[1,:] (a vector) ->Y[[1],:] (a matrix) .\nXX : A type of Markers.\nZ :  An optional m x q matrix of low-dimensional phenotypic covariates, i.e. contrasts, basis functions (fourier, wavelet, polynomials, B-splines, etc.).     If nothing to insert in Z, just exclude it or insert an identity matrix, Matrix(1.0I,m,m).  m traits x q phenotypic covariates.\nLOCO : Boolean. Default is false (no LOCO). Runs genome scan using LOCO (Leave One Chromosome Out).\n\nKeyword Arguments\n\nXnul :  A matrix of covariates. Default is intercepts (1's): Xnul= ones(1,size(Y0)).  Adding covariates (C) is Xnul= vcat(ones(1,m),C) where size(C)=(c,m) for m = size(Y0,1).\nPrior: A positive definite scale matrix, Psi, of prior Inverse-Wishart distributon, i.e. Sigma sim W^-1_m (Psi nu_0).            A large scaled covariance matrix (a weakly informative prior) is default.\ndf_prior: degrees of freedom, nu_0 for Inverse-Wishart distributon.  m+1 (weakly informative) is default.\nitol :  A tolerance controlling ECM (Expectation Conditional Maximization) under H0: no QTL. Default is 1e-3.\ntol0 :  A tolerance controlling ECM under H1: existence of QTL. Default is 1e-3.\ntol : A tolerance of controlling Nesterov Acceleration Gradient method under both H0 and H1. Default is 1e-4.\nρ : A tunning parameter controlling tau^2. Default is 0.001.\nLogP : Boolean. Default is false.  Returns -log_10P instead of LOD scores if true.\n\n!!! Note\n\nWhen some LOD scores return negative values, reduce tolerences for ECM to tol0 = 1e-4. It works in most cases. If not,   can reduce both tol0 and tol to 1e-4 or further.\n\nOutput\n\nLODs (or logP) : LOD scores. Can change to - log_10P in lod2logP if LogP = true.\nB : A 3-d array of B (fixed effects) matrices under H1: existence of QTL.  If covariates are added to Xnul : Xnul= [ones(1,size(Y0)); Covariates],       ex. For sex covariates in 4-way cross analysis, B[:,2,100], B[:,3:5,100] are effects for sex, the rest genotypes of the 100th QTL, respectively.\nest0 : A type of EcmNestrv.Approx including parameter estimates under H0: no QTL.\n\n\n\n\n\n","category":"function"},{"location":"functions/#FlxQTL.flxMLMM.getKc-Tuple{Matrix{Float64}}","page":"Types and Functions","title":"FlxQTL.flxMLMM.getKc","text":"getKc(Y::Array{Float64,2};m=size(Y,1),Z=diagm(ones(m)), df_prior=m+1,\n       Prior::Matrix{Float64}=cov(Y,dims=2)*5,Xnul::Array{Float64,2}=ones(1,size(Y,2)),\n       itol=1e-2,tol::Float64=1e-3,ρ=0.001)\n\nPre-estimate Kc by regressing Y on Xnul, i.e. estimating environmental covariates under H0: no QTL.\n\nArgument\n\nY : A m x n matrix of response variables, i.e. m traits (or environments) by n individuals (or lines). For univariate phenotypes, use square brackets in arguement.       i.e. Y0[1,:] (a vector) ->Y[[1],:] (a matrix) .\n\nKeyword Arguments\n\nZ :  An optional m x q matrix of low-dimensional phenotypic covariates, i.e. contrasts, basis functions (fourier, wavelet, polynomials, B-splines, etc.).       An identity matrix, I_m, is default. \nXnul :  A matrix of covariates. Default is intercepts (1's): Xnul= ones(1,size(Y0)).  Adding covariates (C) is Xnul= vcat(ones(1,m),C) where size(C)=(c,m) for m = size(Y0,1).\nPrior: A positive definite scale matrix, Psi, of prior Inverse-Wishart distributon, i.e. Sigma sim W^-1_m (Psi nu_0).            A large scaled covariance matrix (a weakly informative prior) is default.\ndf_prior: degrees of freedom, nu_0 for Inverse-Wishart distributon.  m+1 (weakly informative) is default.\nitol :  A tolerance controlling ECM (Expectation Conditional Maximization) under H0: no QTL. Default is 1e-3.\ntol : A tolerance of controlling Nesterov Acceleration Gradient method under both H0 and H1. Default is 1e-4.\nρ : A tunning parameter controlling tau^2. Default is 0.001.\n\nOutput\n\nInitKc :  A type of struct of arrays, including pre-estimated Kc,and null estimates of B, Σ,τ2used as initial values inside     gene1Scan, one of geneScan functions, or gene2Scan.\n\nExamples\n\njulia> K0 = getKc(Y)  \njulia> K0.Kc  # for Kc\njulia> K0.B # for B under H0\n\n\n\n\n\n\n","category":"method"},{"location":"functions/#FlxQTL.flxMLMM.permTest-Tuple{Int64, Any, Any, Any, Any, Markers}","page":"Types and Functions","title":"FlxQTL.flxMLMM.permTest","text":"  permTest(nperm::Int64,cross,Kg,Kc,Y,XX::Markers;pval=[0.05 0.01],m=size(Y,1),Z=diagm(ones(m)),df_prior=m+1,\n         Prior::Matrix{Float64}=cov(Y,dims=2)*5,Xnul=ones(1,size(Y,2)),itol=1e-4,tol0=1e-3,tol=1e-4,ρ=0.001)\n  permTest(nperm::Int64,cross,Kg,Y,XX::Markers;pval=[0.05 0.01],df_prior=m+1,\n             Prior::Matrix{Float64}=cov(Y,dims=2)*5,Xnul=ones(1,size(Y,2)),itol=1e-4,tol0=1e-3,tol=1e-4,ρ=0.001)\n\nImplement permutation test to get thresholds at the levels of type 1 error, α.  Note that the last permTest()  is for the conventional MLMM: \n\nvec(Y)sim MVN((I otimes X)vec(B) (or BX) K otimes Sigma_1 +I otimes Sigma_2)\n\nwhere K is a genetic kinship, Sigma_1 Sigma_2 are covariance matrices for random and error terms, respectively.\n\nArguments\n\nnperm : An integer indicating the number of permutation to be implemented.\ncross : An integer indicating the number of alleles or genotypes. Ex. 2 for RIF, 4 for four-way cross, 8 for HS mouse (allele probabilities), etc.         This value is related to degree of freedom when doing genome scan.\nKg : A n x n genetic kinship matrix. Should be symmetric positive definite.\nKc : A m x m climatic relatedness matrix. Should be symmetric positive definite.\nY : A m x n matrix of response variables, i.e. m traits (or environments) by n individuals (or lines). For univariate phenotypes, use square brackets in arguement.       i.e. Y[1,:]  (a vector) -> Y[[1],:]  (a matrix) .\nXX : A type of Markers.\n\nKeyword Arguments\n\npval : A vector of p-values to get their quantiles. Default is [0.05  0.01] (without comma).\nXnul : A matrix of covariates. Default is intercepts (1's).  Unless plugging in particular covariates, just leave as it is.\nZ :  An optional m x q matrix of low-dimensional phenotypic covariates, i.e. contrasts, basis functions (fourier, wavelet, polynomials, B-splines, etc.).       Default is an identity matrix for the dimension of m traits x q phenotypic covariates.\nPrior: A positive definite scale matrix, Psi, of prior Inverse-Wishart distributon, i.e. Sigma sim W^-1_m (Psi nu_0).            A large scaled covariance matrix (a weakly informative prior) is default.\ndf_prior: degrees of freedom, nu_0 for Inverse-Wishart distributon.  m+1 (weakly informative) is default.\nitol : A tolerance controlling ECM (Expectation Conditional Maximization) under H0: no QTL. Default is 1e-3.\ntol0 : A tolerance controlling ECM under H1: existence of QTL. Default is 1e-3.\ntol : A tolerance of controlling Nesterov Acceleration Gradient method under both H0 and H1. Default is 1e-4.\nρ : A tunning parameter controlling tau^2. Default is 0.001.  \n\nOutput\n\nmaxLODs : A nperm x 1 vector of maximal LOD scores by permutation. \nH1par_perm : A type of struct, EcmNestrv.Approx(B,τ2,Σ,loglik) including parameter estimates  or EcmNestrv.Result(B,Vc,Σ,loglik)                for a conventional MLMM under H0: no QTL by permutation. \ncutoff : A vector of thresholds corresponding to pval.\n\n\n\n\n\n","category":"method"},{"location":"functions/#FlxQTL.EcmNestrv","page":"Types and Functions","title":"FlxQTL.EcmNestrv","text":"EcmNestrv\n\nA module for base algorithms using ECM (Expectation-Conditional Maxization) with Speed restarting Nesterov's accelerated gradient method  to fit a flexible multivariate linear mixed model (flxMLMM).\n\n\n\n\n\n","category":"module"},{"location":"functions/#Genetic-Relatedness-Matrices-(GRM)","page":"Types and Functions","title":"Genetic Relatedness Matrices (GRM)","text":"","category":"section"},{"location":"functions/","page":"Types and Functions","title":"Types and Functions","text":"Modules = [GRM]","category":"page"},{"location":"functions/#FlxQTL.GRM","page":"Types and Functions","title":"FlxQTL.GRM","text":" GRM\n\nA module for computing Genetic Relatedness Matrix (or kinship).\n\n\n\n\n\n","category":"module"},{"location":"functions/#FlxQTL.GRM.kinship4way-Tuple{Matrix{Float64}}","page":"Types and Functions","title":"FlxQTL.GRM.kinship4way","text":" kinship4way(genmat::Array{Float64,2})\n\nComputes a kinship for four-way cross data counting different alleles between two markers: ex. AB-AB=0; AB-AC=1; AB-CD=2,dots Note: In R/qtl, genotypes are labeled as 1=AC; 2=BC; 3=AD; 4=BD by the function, read.cross.\n\nArgument\n\ngenmat : A matrix of genotypes for four-way cross (12 dots).          size(genematrix)= (p,n), for p genetic markers x n individuals(or lines).\n\nOutput\n\nReturns a n x n symmetric matrix containing 1's on the diagonal.\n\n\n\n\n\n","category":"method"},{"location":"functions/#FlxQTL.GRM.kinshipCtr-Tuple{Matrix{Float64}}","page":"Types and Functions","title":"FlxQTL.GRM.kinshipCtr","text":" kinshipCtr(genmat::Array{Float64,2})\n\nCalculates a kinship by a centered genotype matrix (linear kernel), i.e. genotypes subtracted by marker mean.\n\nArgument\n\ngenmat : A matrix of genotype data (0,1,2). size(genmat)=(p,n) for p markers x n individuals\n\nOutput\n\nReturns a n x n symmetric matrix. See also kinshipStd.\n\n\n\n\n\n","category":"method"},{"location":"functions/#FlxQTL.GRM.kinshipGs-Tuple{Matrix{Float64}, Float64}","page":"Types and Functions","title":"FlxQTL.GRM.kinshipGs","text":" kinshipGs(climate::Array{Float64,2},ρ::Float64)\n\nComputes a kinship matrix using the Gaussian Kernel.\n\nArguments\n\nclimate : A matrix of genotype, or climate information data. size(climate)=(r,m), such that r genotype markers (or days/years of climate factors,           i.e. precipitations, temperatures, etc.), and m individuals (or environments/sites)\nρ : A free parameter determining the width of the kernel. Could be attained empirically.\n\nOutput\n\nReturns a m x m symmetric (positive definite) matrix containing 1's on the diagonal.\n\n\n\n\n\n","category":"method"},{"location":"functions/#FlxQTL.GRM.kinshipLin-Tuple{Any, Any}","page":"Types and Functions","title":"FlxQTL.GRM.kinshipLin","text":"kinshipLin(mat,cross)\n\nCalculates a kinship (or climatic relatedness, kinshipGs) matrix by linear kernel.\n\nArguments\n\nmat : A matrix of genotype (or allele) probabilities usually extracted from R/qtl,       R/qtl2, or the counterpart packages. size(mat)= (p,n) for p genetic markers x n individuals.\ncross : A scalar indicating instances of alleles or genotypes in a genetic marker. ex. 1 for genotypes (labeled as 0,1,2), 2 for RIF, 4 for four-way cross, 8 for HS mouse (allele probabilities), etc.\n\nOutput\n\nReturns a n x n symmetric (positive definite) matrix containing 1's on the diagonal.\n\nSee also kinshipCtr, kinshipStd for genetype data.\n\n\n\n\n\n","category":"method"},{"location":"functions/#FlxQTL.GRM.kinshipLoco","page":"Types and Functions","title":"FlxQTL.GRM.kinshipLoco","text":" kinshipLoco(kin,g::Markers,cross::Int64=1)\n\nGenerates a 3-d array of symmetric positive definite kinship matrices using LOCO (Leave One Chromosome Out) witout shrinkage intensity estimation. When a kinship is not positive definite, a tweak like a weighted average of kinship and Identity is used to correct minuscule negative eigenvalues.\n\nArguments\n\nkin :  A function of computing a kinship. Can only use with kinshipCtr, kinshipStd for genotypes, and with kinshipLin         for genotype (or allele) probabilities.\ng   : A struct of arrays, type  Markers.\ncross :  A scalar indicating instances of alleles or genotypes in a genetic marker.            ex. 1 for genotypes (0,1,2) as default, 2 for RIF, 4 for four-way cross, 8 for HS mouse (allele probabilities), etc.\n\nOutput\n\nReturns 3-d array of n x n symmetric positive definite matrices as many as Chromosomes. Refer to shrinkgLoco.\n\n\n\n\n\n","category":"function"},{"location":"functions/#FlxQTL.GRM.kinshipMan-Tuple{Matrix{Float64}}","page":"Types and Functions","title":"FlxQTL.GRM.kinshipMan","text":"  kinshipMan(genematrix::Array{Float64,2})\n\nCalculates a kinship matrix using a manhattan distance. Missing values need to be either omitted or imputed. This function is for recombinant inbred line (RIL) (AA/BB), not for 4-way cross genotype data.  See kinship4way.\n\nArgument\n\ngenematrix : A matrix of genotypes, i.e. 0,1 (or 1,2).  size(genematrix)= (p,n) for p genetic markers x n individuals(or lines).\n\nOutput\n\nReturns a n x n symmetric matrix containing 1's on the diagonal.\n\n\n\n\n\n","category":"method"},{"location":"functions/#FlxQTL.GRM.kinshipStd-Tuple{Matrix{Float64}}","page":"Types and Functions","title":"FlxQTL.GRM.kinshipStd","text":" kinshipStd(genmat::Array{Float64,2})\n\nCalculates a kinship by a standardized (or normalized) genotype matrix (linear kernel), i.e. genotypes subtracted by marker mean and divided by marker standard deviation. Can also do with climatic information data. See kinshipGs.\n\nArgument\n\ngenmat : A matrix of genotype data (0,1,2). size(genmat)=(p,n) for p markers x n individuals\n\nOutput\n\nReturns a n x n symmetric matrix. See also kinshipCtr.\n\n\n\n\n\n","category":"method"},{"location":"functions/#FlxQTL.GRM.shrinkg-Tuple{Any, Int64, Any}","page":"Types and Functions","title":"FlxQTL.GRM.shrinkg","text":" shrinkg(f,nb::Int64,geno)\n\nEstimates a full-rank positive definite kinship matrix by shrinkage intensity estimation (bootstrap).  Can only use with kinshipMan, kinship4way. This function runs faster by CPU parallelization.  Add workers/processes using addprocs() function before running for speedup.\n\nArguments\n\nf: A function of computing a kinship. Can only use with kinshipMan, kinship4way.\nnb : An integer indicating the number of bootstrap. It does not have to be a large number.\ngeno : A matrix of genotypes. See kinshipMan, kinship4way for dimension.\n\nExample\n\njulia> using FlxQTL\njulia> addprocs(8)\njulia> K = shinkage(kinshipMan,20,myGeno)\n\nOutput\n\nReturns a full-rank symmetric positive definite matrix.\n\n\n\n\n\n","category":"method"},{"location":"functions/#FlxQTL.GRM.shrinkgLoco-Tuple{Any, Int64, Markers}","page":"Types and Functions","title":"FlxQTL.GRM.shrinkgLoco","text":"   shrinkgLoco(kin,nb,g::Markers)\n\nGenerates 3-d array of full-rank positive definite kinship matrices by shrinkage intensity estimation (bootstrap) using a LOCO (Leave One Chromosome Out) scheme.\n\nArgument\n\nkin :  A function of computing a kinship. Can only use with kinshipMan, kinship4way\nnb : An integer indicating the number of bootstrap.\ng : A struct of arrays, type Markers.\n\nOutput\n\nReturns 3-d array of n x n symmetric positive definite matrices as many as Chromosomes.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Multivariate-Linear-Models-(MLM)","page":"Types and Functions","title":"Multivariate Linear Models (MLM)","text":"","category":"section"},{"location":"functions/","page":"Types and Functions","title":"Types and Functions","text":"Modules = [MLM]","category":"page"},{"location":"functions/#FlxQTL.MLM","page":"Types and Functions","title":"FlxQTL.MLM","text":"  MLM\n\nA module for fitting general Multivariate Linear Models motivated by functional data analysis via mle or reml. The default fitting method is mle. ( i.e. reml=false)\n\nThe model:  Y=XBZ+E, where E(Y)=XBZ (or E(vec(Y))= (Z otimes X)vec(B) ),  var(vec(E))=Sigma otimes I size(Y)=(n,m), size(X)=(n,p), size(Z)=(m,q).\n\n\n\n\n\n","category":"module"},{"location":"functions/#FlxQTL.MLM.Estimat","page":"Types and Functions","title":"FlxQTL.MLM.Estimat","text":" Estimat(B::Array{Float64,2},Σ::Array{Float64,2},loglik::Float64)\n\nA struct of arrays for results by fitting a multivariate linear model,  mGLM().   The results are B(fixed effects), Σ (m x m covariance matrix), loglik(a value of log-likelihood by mle or reml).\n\n\n\n\n\n","category":"type"},{"location":"functions/#FlxQTL.MLM.mGLM","page":"Types and Functions","title":"FlxQTL.MLM.mGLM","text":"  mGLM(Y::Array{Float64,2},X::Array{Float64,2},Z::Array{Float64,2},reml::Bool=false)\n  mGLM(Y::Array{Float64,2},X::Array{Float64,2},reml::Bool=false)\n\nFitting multivariate General Linear Models via MLE (or REML) and returns a type of a struct Estimat.  \n\nArguments\n\nY : A matrix of response variables, i.e. traits. size(Y)=(n,m) for n individuals x m traits\nX : A matrix of independent variables, i.e. genotypes or genotype probabilities including intercept or/and covariates. size(X)=(n,p) for n individuals x p markers      including intercept or/and covariates \nZ : An optional matrix of low-dimensional phenotypic covariates, i.e. contrasts, basis functions (fourier, wavelet, polynomials, B-splines, etc.).      If nothing to insert in Z, just exclude it or insert Matrix(1.0I,m,m). size(Z)=(m,q) for m traits x q phenotypic covariates.\nreml : Boolean. Default is fitting the model via mle. Resitricted MLE is implemented if true. \n\nOutput\n\nReturns Estimat .\n\n\n\n\n\n","category":"function"},{"location":"functions/#Utility-Functions-(Util)","page":"Types and Functions","title":"Utility Functions (Util)","text":"","category":"section"},{"location":"functions/","page":"Types and Functions","title":"Types and Functions","text":"Modules = [Util]","category":"page"},{"location":"functions/#FlxQTL.Util","page":"Types and Functions","title":"FlxQTL.Util","text":" Util\n\nA module for utility functions.\n\n\n\n\n\n","category":"module"},{"location":"functions/#FlxQTL.Util.Markers","page":"Types and Functions","title":"FlxQTL.Util.Markers","text":"Markers(name::Array{String,1},chr::Array{Any,1},pos::Array{Float64,1},X::Array{Float64,2})\n\nA struct of arrays creating genotype or genotype probability data for genome scan.\n\nArguments\n\nname : A vector of marker names\nchr  : A vector of Chromosomes\npos  : A vector of marker positions (cM)\nX : A matrix of genotypes or genotype probabilities\n\n\n\n\n\n","category":"type"},{"location":"functions/#FlxQTL.Util.Y_huber-Tuple{Matrix{Float64}}","page":"Types and Functions","title":"FlxQTL.Util.Y_huber","text":"Y_huber(Y::Array{Float64,2})\n\nRescale Y (phenotype or trait data) to be less sensitive to outliers using by Huber loss function and MAD (median absolute deviation).  size(Y)=(m,n) for m trait and n individuals.\n\n\n\n\n\n","category":"method"},{"location":"functions/#FlxQTL.Util.array2mat-Tuple{Int64, Array{Float64, 3}}","page":"Types and Functions","title":"FlxQTL.Util.array2mat","text":" array2mat(cross::Int64,X0::Array{Float64,3})\n\nReturns a 3-d array to a matrix of genotype probabilities. size(X0)=(p,cross,n) –> (p1,n), where p1 = cross*p for p markers,  cross alleles or genotypes, and n individuals. See mat2array.\n\n\n\n\n\n","category":"method"},{"location":"functions/#FlxQTL.Util.getFinoidx-Tuple{Matrix{Union{Missing, Float64}}}","page":"Types and Functions","title":"FlxQTL.Util.getFinoidx","text":"getFinoidx(phenoData::Array{Union{Missing,Float64},2})\n\nAttains indices of phenotype data without missing values.\n\nArgument\n\nphenoData : A matrix of phenotype (or trait) data including missing values. size(phenoData) = (m,n) for m traits and n individuals.\n\n\n\n\n\n","category":"method"},{"location":"functions/#FlxQTL.Util.getGenoidx","page":"Types and Functions","title":"FlxQTL.Util.getGenoidx","text":"getGenoidx(GenoData::Union{Array{Any,2},Array{Float64,2}},maf::Float64=0.025)\n\nAttains genotype indices to drop correlated or bad markers.\n\nArguments\n\nGenoData : A matrix of genotype data. size(GenoData)= (p,n) for p markers and n individuals.\nmaf : A scalar for dropping criterion of markers. Default is 0.025 i.e. markers of MAF < 0.025 are dropped.\n\n\n\n\n\n","category":"function"},{"location":"functions/#FlxQTL.Util.lod2logP-Tuple{Union{Vector{Any}, Vector{Float64}}, Int64}","page":"Types and Functions","title":"FlxQTL.Util.lod2logP","text":"lod2logP(LODs::Union{Array{Float64,1},Array{Any,1}},v::Int64)\n\nCaculates -log_10P from LOD scores.\n\nArguments\n\nLODs : A vector of LOD scores computed from genome scan.\nv : Degrees of freedom for Chi-squared distribution.  \n\n!!! NOTE\n\nTo compute degrees of freedom for 1D-genome scan (geneScan), v = prod(size(B1))-prod(size(B0), where B1 and B0 are effect size matrices under H1 of a full model (intercept + covariates + QTL) and H0 of no QTL (intercept + covariates), respectively.\n\n\n\n\n\n","category":"method"},{"location":"functions/#FlxQTL.Util.mat2array-Tuple{Int64, Any}","page":"Types and Functions","title":"FlxQTL.Util.mat2array","text":" mat2array(cross::Int64,X0)\n\nReturns a matrix of genotype probabilities to 3-d array. size(X0)=(p1,n) –> (p,cross,n), where p1 = cross*p for p markers,  cross alleles or genotypes, and n individuals.\n\nArgument\n\ncross : An integer indicating the number of alleles or genotypes. Ex. 2 for RIF, 4 for four-way cross, 8 for HS mouse (allele probabilities), etc.\nX0 : A matrix of genotype probability data computed from r/qtl or r/qtl2.  \n\nSee array2mat.\n\n\n\n\n\n","category":"method"},{"location":"functions/#FlxQTL.Util.mat2vec-Tuple{Any}","page":"Types and Functions","title":"FlxQTL.Util.mat2vec","text":" mat2vec(mat)\n\nStacks a matrix to a vector, i.e. vectorizing a matrix.\n\n\n\n\n\n","category":"method"},{"location":"functions/#FlxQTL.Util.newMarkers","page":"Types and Functions","title":"FlxQTL.Util.newMarkers","text":"newMarkers(XX::Markers,cross::Int64,cM::Int64=2)\n\nReturns a struct of Markers by keeping only markers positioned in every cM centimorgans for 2-d genome scan to avoid singularity.\n\nArguments\n\nXX : A type of Markers. See Markers.\ncross : An integer indicating the number of alleles or genotypes. Ex. 2 for RIF, 4 for four-way cross, 8 for HS mouse (allele probabilities), etc.\ncM : An integer of dropping criterion of markers. Default is 2, i.e. keeping only markers in every 2 cM, or dropping markers within 2cM between 2 markers.\n\n\n\n\n\n","category":"function"},{"location":"functions/#FlxQTL.Util.ordrMarkers-Tuple{Matrix{Any}}","page":"Types and Functions","title":"FlxQTL.Util.ordrMarkers","text":"ordrMarkers(markers::Array{Any,2})\n\nRearrange by CPU parallelization marker information composed of marker name, chr, position obtained from rqtl2, which is not listed in order (excluding X chromosome).\n\nArgument\n\nmarkers : An array of marker information.\n\n\n\n\n\n","category":"method"},{"location":"functions/#FlxQTL.Util.setSeed-Tuple{Int64}","page":"Types and Functions","title":"FlxQTL.Util.setSeed","text":"setSeed(seedNum::Int64)\n\nAssigns different numbers of seeds to workers (or processes) for reproducibility.\n\nArguments\n\nseedNum: An integer.  A minimum seed number to assign a worker.  For distributed computing, seed numbers are generated for multiple workers by increasing 1, e.g. seedNum = 123 & 10 workers, setSeed generates seeds from 123 to 132 and assigns to corresponding workers (processes). \n\nExamples\n\njulia> using Distributed\njulia> addprocs(10)\njulia> @everywhere using flxQTL\njulia> setSeed(123)\n\n\n\n\n\n\n","category":"method"},{"location":"functions/#FlxQTL.Util.sortBycM","page":"Types and Functions","title":"FlxQTL.Util.sortBycM","text":"    sortBycM(Chr::Any,XX::Markers,cross::Int64,cM::Int64=2)\n\nReturns marker indices in Chromosome Chr and the corresponding genotype probabilities keeping only markers positioned in every cM centimorgans  for 2-d genome scan to avoid singularity.\n\nArguments\n\nChr : A type of Any indicating a particular chromosome to sort markers out.\nXX : A type of Markers.\ncross : An integer indicating the number of alleles or genotypes. Ex. 2 for RIF, 4 for four-way cross, 8 for HS mouse (allele probabilities), etc.\ncM : An integer of dropping criterion of markers. Default is 2, i.e. keeping only markers in every 2 cM, or dropping markers within 2cM between 2 markers.\n\nSee also newMarkers\n\n\n\n\n\n","category":"function"},{"location":"guide/analysis/#QTL-analysis","page":"QTL Analysis","title":"QTL analysis","text":"","category":"section"},{"location":"guide/analysis/","page":"QTL Analysis","title":"QTL Analysis","text":"This section describes a step-by-step instruction for QTL analysis.","category":"page"},{"location":"guide/analysis/#Input-data-file-format","page":"QTL Analysis","title":"Input data file format","text":"","category":"section"},{"location":"guide/analysis/","page":"QTL Analysis","title":"QTL Analysis","text":"The package FlxQTL does not require any particular data format.  Any file readable in Julia is fine, but the input should contain traits (or phenotypes), genotypes (or genotype probabilities), marker information on marker names, chromosomes, and marker positions.  All inputs are types of  Arrays in Julia and should have no missing values, i.e. imputation is required if missing values exist.","category":"page"},{"location":"guide/analysis/#Reading-the-data-files-and-processing-arrays","page":"QTL Analysis","title":"Reading the data files and processing arrays","text":"","category":"section"},{"location":"guide/analysis/","page":"QTL Analysis","title":"QTL Analysis","text":"Use any Julia package able to read data files (.txt, .csv, etc.).  Julia's built-in module DelimitedFiles supports read, and write files.  Let's try using an example dataset in FlxQTL. It is plant data: Arabidopsis thaliana in the data folder.  Detailed description on the data can be  referred to README in the folder.","category":"page"},{"location":"guide/analysis/","page":"QTL Analysis","title":"QTL Analysis","text":"using DelimitedFiles\n\npheno = readdlm(\"data/Arabidopsis_fitness.csv\",',';skipstart=1); # skip to read the first row (column names) to obtain a matrix only\n\ngeno = readdlm(\"data/Arabidopsis_genotypes.csv\",',';skipstart=1); \n\nmarkerinfo = readdlm(\"data/Arabidopsis_markerinfo_1d.csv\",',';skipstart=1);","category":"page"},{"location":"guide/analysis/","page":"QTL Analysis","title":"QTL Analysis","text":"For efficient computation, the normalization of matrices is necessary.  The phenotype matrix labelled as pheno here composes of a wide range of values  from 1.774 to 34.133, so that it is better to narow the range of values in [0,1], [-1,1], or any narrower interval for easy computation.  Note that  the dimension of a phenotype matrix should be the number of traits x the number of individuals, i.e. m x n.","category":"page"},{"location":"guide/analysis/","page":"QTL Analysis","title":"QTL Analysis","text":"using Statistics, StatsBase\nY=convert(Array{Float64,2},pheno'); #convert from transposed one to a Float64 matrix\nYstd=(Y.-mean(Y,dims=2))./std(Y,dims=2); # sitewise normalization","category":"page"},{"location":"guide/analysis/","page":"QTL Analysis","title":"QTL Analysis","text":"!!! Note","category":"page"},{"location":"guide/analysis/","page":"QTL Analysis","title":"QTL Analysis","text":"If the data are skewed or have outliers, simple standadization may not resolve them.  You may use a Y_huber function to rescale the data to be less sensitve to outliers.","category":"page"},{"location":"guide/analysis/","page":"QTL Analysis","title":"QTL Analysis","text":"In the genotype data, 1, 2 indicate Italian, Swedish parents, respectively. You can rescale the genotypes for efficiency. ","category":"page"},{"location":"guide/analysis/","page":"QTL Analysis","title":"QTL Analysis","text":"geno[geno.==1.0].=0.0;geno[geno.==2.0].=1.0; # or can do geno[geno.==1.0].=-1.0 for only genome scan","category":"page"},{"location":"guide/analysis/","page":"QTL Analysis","title":"QTL Analysis","text":"For genome scan, we need restructure the standardized genotype matrix combined with marker information.  Note that the genome scan in FlxQTL is  implemented by CPU parallelization, so we need to add workers (or processes) before the genome scan.  Depending on the computer CPU, one can add as many  processes as possible. If your computer has 16 cores, then you can add 15 or little more.  Note that you need to type @everywhere followed by using PackageName for parallel computing.  The dimension of a genotype (probability) matrix should be  the number of markers x the number of individuals, i.e. p x n.","category":"page"},{"location":"guide/analysis/","page":"QTL Analysis","title":"QTL Analysis","text":"using Distributed\naddprocs(4) \n@everywhere using FlxQTL \nXX=Markers(markerinfo[:,1],markerinfo[:,2],markerinfo[:,3],geno') # marker names, chromosomes, marker positions, genotypes","category":"page"},{"location":"guide/analysis/","page":"QTL Analysis","title":"QTL Analysis","text":"<!– - Julia tip: Whenever you reload a package, i.e. using FlxQTL, you should re-enter XX=FlxQTL.Markers(markerinfo[:,1],markerinfo[:,2],markerinfo[:,3],geno') to fresh the struct of array.  If not, your genome scan throws an error.  You should also do with another struct of array in a submodule QTLplot, FlxQTL.layers. –>","category":"page"},{"location":"guide/analysis/","page":"QTL Analysis","title":"QTL Analysis","text":"Optionally, one can generate a trait covariate matrix (Z).  The first column indicates overall mean between the two regions, and  the second implies site difference: -1 for Italy, and 1 for Sweden.","category":"page"},{"location":"guide/analysis/","page":"QTL Analysis","title":"QTL Analysis","text":"Z=hcat(ones(6),vcat(-ones(3),ones(3)))\nm,q = size(Z) # check the dimension","category":"page"},{"location":"guide/analysis/#Computing-a-genetic-relatedness-matrix-(GRM)-and-pre-computing-a-covariance-structure-for-a-random-matrix-(Kc)","page":"QTL Analysis","title":"Computing a genetic relatedness matrix (GRM) and pre-computing a covariance structure for a random matrix (Kc)","text":"","category":"section"},{"location":"guide/analysis/","page":"QTL Analysis","title":"QTL Analysis","text":"The submodule GRM contains functions for computing kinship matrices, kinshipMan, kinship4way, kinshipGs, kinshipLin, kinshipCtr, and computing  3D array of kinship matrices for LOCO (Leave One Chromosome Out) with a shrinkage method for nonpositive definiteness,  shrinkg, shrinkgLoco, kinshipLoco.   Note that the shrinkage option is only used for kinshipMan, kinship4way.","category":"page"},{"location":"guide/analysis/","page":"QTL Analysis","title":"QTL Analysis","text":"For the Arabidopsis genotype data, we will use a genetic relatedness matrix using manhattan distance measure, kinshipMan with a shrinkage with  the LOCO option.","category":"page"},{"location":"guide/analysis/","page":"QTL Analysis","title":"QTL Analysis","text":"Kg = shrinkgLoco(kinshipMan,10,XX)","category":"page"},{"location":"guide/analysis/","page":"QTL Analysis","title":"QTL Analysis","text":"For no LOCO option with shrinkage,","category":"page"},{"location":"guide/analysis/","page":"QTL Analysis","title":"QTL Analysis","text":"K = shrinkg(kinshipMan,10,XX.X)","category":"page"},{"location":"guide/analysis/","page":"QTL Analysis","title":"QTL Analysis","text":"For computational efficiency, a getKc function pre-computes a covariance structured matrix for the random term, i.e., Kc in \\\\tau^2 Kc \\\\approx \\\\Sigma_1.   One can separately pre-compute Kc and run geneScan or just run gene1Scan, in which getKc precomputes Kc.  ","category":"page"},{"location":"guide/analysis/","page":"QTL Analysis","title":"QTL Analysis","text":"using LinearAlgebra\nK1= getKc(Ystd;Z=Z);\nK1.Kc ","category":"page"},{"location":"guide/analysis/#1D-genome-scan","page":"QTL Analysis","title":"1D genome scan","text":"","category":"section"},{"location":"guide/analysis/","page":"QTL Analysis","title":"QTL Analysis","text":"Once all input matrices are ready, we need to proceed the eigen-decomposition to two relatedness matrices.  For a precomputed random covariance structured matrix, and a kinship with LOCO, you can do eigen-decomposition simultaneously.  ","category":"page"},{"location":"guide/analysis/","page":"QTL Analysis","title":"QTL Analysis","text":"Tg,Λg,Tc,λc = K2Eig(Kg,K1.Kc,true); # the last argument: LOCO::Bool = false (default)","category":"page"},{"location":"guide/analysis/","page":"QTL Analysis","title":"QTL Analysis","text":"Or,","category":"page"},{"location":"guide/analysis/","page":"QTL Analysis","title":"QTL Analysis","text":"Tg,λg = K2eig(Kg, true) # for eigen decomposition to one kinship with LOCO","category":"page"},{"location":"guide/analysis/","page":"QTL Analysis","title":"QTL Analysis","text":"For eigen decomposition to one kinship with no LOCO option,","category":"page"},{"location":"guide/analysis/","page":"QTL Analysis","title":"QTL Analysis","text":"T,λ = K2eig(K)","category":"page"},{"location":"guide/analysis/","page":"QTL Analysis","title":"QTL Analysis","text":"Now start with 1D genome scan with (or without) LOCO including Z or not.   For the genome scan with LOCO including Z, ","category":"page"},{"location":"guide/analysis/","page":"QTL Analysis","title":"QTL Analysis","text":"LODs,B,est0 = geneScan(1,Tg,Tc,Λg,λc,Ystd,XX,Z,true); # FlxQTL for including Z (trait covariates)","category":"page"},{"location":"guide/analysis/","page":"QTL Analysis","title":"QTL Analysis","text":"For the genome scan with LOCO excluding Z, i.e. an identity matrix, we have two options: a FlxQTL model and a conventional MLMM ","category":"page"},{"location":"guide/analysis/","page":"QTL Analysis","title":"QTL Analysis","text":"LODs,B,est0 = geneScan(1,Tg,Tc,Λg,λc,Ystd,XX,true); # FlxQTL for Z=I \n\nLODs,B,est0 = geneScan(1,Tg,Tc,Λg,λc,Ystd,XX,diagm(ones(m)),true); # or equivalently, FlxQTL for Z=I \n\nlods,b,Est0 = geneScan(1,Tg,Λg,Ystd,XX,true); # MLMM","category":"page"},{"location":"guide/analysis/","page":"QTL Analysis","title":"QTL Analysis","text":"Note that the first argument in geneScan is cross::Int64, which indicates a type of genotype or genotype probability.  For instance, if you use a  genotype matrix whose entry is one of 0,1,2, type 1. If you use genotype probability matrices, depending on the number of alleles or genotypes in a marker, one can type the corresponding number. i.e. 4-way cross: 4, HS DO mouse: 8 for alleles, 32 for genotypes, etc.  Now the new verson of FlxQTL is operated by penalized log-likelihood function using Prior with df_prior for a error term, Sigma, distributed by Inverse-Wishart distribution for numerial stability.  One can also adjust them in the Keyword arguments.  The default positive definite scale matrix is a large scaled matrix (cov(Y,dims=2)*5).  We recommend using a large scale matrix for computational efficiency.","category":"page"},{"location":"guide/analysis/","page":"QTL Analysis","title":"QTL Analysis","text":"For no LOCO option,","category":"page"},{"location":"guide/analysis/","page":"QTL Analysis","title":"QTL Analysis","text":"LOD,B1,est00 = geneScan(1,T,Tc,λ,λc,Ystd,XX,Z);\n\nLOD,B1,est00 = geneScan(1,T,Tc,λ,λc,Ystd,XX); # Z=I\n\nLOD,B1,est00 = geneScan(1,T,Tc,λ,λc,Ystd,XX,diagm(ones(m))); #Z=I\n\nlod,b1,Est00 = geneScan(1,T,λ,Ystd,XX); # MLMM","category":"page"},{"location":"guide/analysis/","page":"QTL Analysis","title":"QTL Analysis","text":"One can also use gene1Scan, so that you do not have to precompute Kc.","category":"page"},{"location":"guide/analysis/","page":"QTL Analysis","title":"QTL Analysis","text":"\nLODs,B,est0 = gene1Scan(1,Tg,Λg,Ystd,XX,Z,true); \n\nLODs,B,est0 = gene1Scan(1,Tg,Λg,Ystd,XX,true); # for Z=I\n\nLODs,B,est0 = gene1Scan(1,Tg,Λg,Ystd,XX,diagm(ones(m)),true); # equivalently, for Z=I","category":"page"},{"location":"guide/analysis/","page":"QTL Analysis","title":"QTL Analysis","text":"For no LOCO option,","category":"page"},{"location":"guide/analysis/","page":"QTL Analysis","title":"QTL Analysis","text":"LOD,B1,est00 = gene1Scan(1,T,λ,Ystd,XX,Z);\n\n","category":"page"},{"location":"guide/analysis/","page":"QTL Analysis","title":"QTL Analysis","text":"The function geneScan has three arguments: LOD scores (LODs), effects matrix under H1 (B), and parameter estimates under H0 (est0), which  is an Array{Any,1}.  If you want to see null parameter esitmate in chromosome 1 for LOCO option, type est0[1].B, est0[1].loglik, est0[1].τ2,  est0[1].Σ.    In particular, you can extract values from each matrix in B (3D array of matrices) to generate an effects plot. To print an effect size matrix for the  third marker, type B[:,:,3], where the last dimension is the order of a marker in the genotype (probability) data.","category":"page"},{"location":"guide/analysis/#Generating-plots","page":"QTL Analysis","title":"Generating plots","text":"","category":"section"},{"location":"guide/analysis/","page":"QTL Analysis","title":"QTL Analysis","text":"The QTLplot module is currently unavailable but plotting functions will be replaced with BigRiverQTLPlots.jl soon.","category":"page"},{"location":"guide/analysis/","page":"QTL Analysis","title":"QTL Analysis","text":"(Image: arabidopsis)","category":"page"},{"location":"guide/analysis/#Performing-a-permutation-test","page":"QTL Analysis","title":"Performing a permutation test","text":"","category":"section"},{"location":"guide/analysis/","page":"QTL Analysis","title":"QTL Analysis","text":"Since the statistical inference for FlxQTL relies on LOD scores, the function permTest finds thresholds for a type I error.   The first argument is nperm::Int64 to set the number of permutations for the test.  For keyword arguments, pval=[0.05 0.01] is default to get thresholds of type I error rates (α), and the identity matrix, i.e. Z=diagm(ones(m)) is default.  Note that permutation test is implemented by no LOCO option since the difference between no LOCO and LOCO options for many simulations would be very minor.","category":"page"},{"location":"guide/analysis/","page":"QTL Analysis","title":"QTL Analysis","text":"maxLODs, H1par_perm, cutoff = permTest(1000,1,K,Kc,Ystd,XX;Z=Z,pval=[0.05]) # cutoff at 5 %\n\nmaxlods, H1par_perm1, cutoff1 = permTest(1000,1,K,Ystd,XX;pval=[0.05])  # for MLMM\n","category":"page"},{"location":"guide/analysis/#2D-genome-scan","page":"QTL Analysis","title":"2D genome scan","text":"","category":"section"},{"location":"guide/analysis/","page":"QTL Analysis","title":"QTL Analysis","text":"A gene2Scan function has two options just as geneScan and gene1Scan functions.  Note that one needs a coarser genotype (probability) matrix since  the distance between any two markers in a chromosome is very close each other, often yielding a numerical error during the operation.  This will be worse when the conversional MLMM is chosen to implement.     The provided data for 2D scan are generated by the R/qtl library with a sim.geno function by picking one of the simulated data sets, where step=5 and draws=16 were set.","category":"page"},{"location":"guide/analysis/","page":"QTL Analysis","title":"QTL Analysis","text":"geno_2d = readdlm(\"data/Arabidopsis_genotypes_2d.csv\",',';skipstart=1); \n\nmarkerinfo_2d = readdlm(\"data/Arabidopsis_markerinfo_2d.csv\",',';skipstart=1);\n\ngeno_2d[geno_2d.==1.0].=0.0;geno_2d[geno_2d.==2.0].=1.0; # or can do geno_2d[geno_2d.==1.0].=-1.0 for only genome scan\n\nX2=Markers(markerinfo_2d[:,1],markerinfo_2d[:,2],markerinfo_2d[:,3],geno_2d) # marker names, \n\nLOD_2d,B2,est02 = gene2Scan(1,T,Tc,Λg,λc,Ystd,XX,Z,true); \n\nLOD_2d,B2,est02 = gene2Scan(1,T,Tc,Λg,λc,Ystd,XX,diagm(one(m)),true);  # for Z=I\n\nLOD_2d,B2,est02 = gene2Scan(1,Tg,Λg,Ystd,XX,Z,true); # precomputing Kc inside the function\n\nlod_2d,b2,Est02 = gene2Scan(1,Tg,Λg,Ystd,XX,true) # MLMM","category":"page"},{"location":"guide/analysis/","page":"QTL Analysis","title":"QTL Analysis","text":"Or one can do with no LOCO as explained as in aforementioned 1D genome scan.","category":"page"},{"location":"#FlxQTL.jl","page":"Home","title":"FlxQTL.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A package for a Flexible multivariate linear mixed model (MLMM) suitable for QTL (Quantitative Trait Loci) analysis of structured multivariate traits. ","category":"page"},{"location":"#Package-Features","page":"Home","title":"Package Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Genome scan (1D, 2D) for univariate, multivariate trait(s), and genotype (probability) data\nLOCO (Leave One Chromosome Out) support for genome scan \nComputation for Genetic (or Climatic) Relatedness matrix (or kinship) \nCPU parallelization","category":"page"},{"location":"#Guide","page":"Home","title":"Guide","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"guide/tutorial.md\",\n        \"guide/analysis.md\",   \n        ]\nDepth = 1\n","category":"page"},{"location":"#Manual","page":"Home","title":"Manual","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The descriptions of functions and types arranged by module.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"functions.md\"]\n","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"functions.md\"]","category":"page"},{"location":"guide/tutorial/#Package-Guide","page":"Package Guide","title":"Package Guide","text":"","category":"section"},{"location":"guide/tutorial/#Installation","page":"Package Guide","title":"Installation","text":"","category":"section"},{"location":"guide/tutorial/","page":"Package Guide","title":"Package Guide","text":"The package can installed in following ways. In a Julia REPL, press ] to enter a package mode,","category":"page"},{"location":"guide/tutorial/","page":"Package Guide","title":"Package Guide","text":"pkg> add FlxQTL","category":"page"},{"location":"guide/tutorial/","page":"Package Guide","title":"Package Guide","text":"Or, equivalently, ","category":"page"},{"location":"guide/tutorial/","page":"Package Guide","title":"Package Guide","text":"julia> using Pkg; Pkg.add(\"FlxQTL\")","category":"page"},{"location":"guide/tutorial/","page":"Package Guide","title":"Package Guide","text":"To remove the package from the Julia REPL,","category":"page"},{"location":"guide/tutorial/","page":"Package Guide","title":"Package Guide","text":"pkg> rm FlxQTL","category":"page"},{"location":"guide/tutorial/","page":"Package Guide","title":"Package Guide","text":"Equivalently,","category":"page"},{"location":"guide/tutorial/","page":"Package Guide","title":"Package Guide","text":"julia> using Pkg; Pkg.rm(\"FlxQTL\")","category":"page"},{"location":"guide/tutorial/#Choice-of-BLAS-vendors","page":"Package Guide","title":"Choice of BLAS vendors","text":"","category":"section"},{"location":"guide/tutorial/","page":"Package Guide","title":"Package Guide","text":"The package can be run in either openblas (built-in Julia dense linear algebra routines) or MKL (intel MKL linear algebra).   Without the intel MKL hardware, the installation of MKL.jl in Julia can slightly improve the performance.   For its installation, consult with MKL.jl.","category":"page"}]
}
