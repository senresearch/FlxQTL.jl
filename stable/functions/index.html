<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Types and Functions · FlxQTL.jl</title><link rel="canonical" href="https://hkim89.github.io/FlxQTL.jl/stable/functions/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">FlxQTL.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../guide/tutorial/">Guide</a></li><li><a class="tocitem" href="../guide/analysis/">QTL analysis</a></li><li class="is-active"><a class="tocitem" href>Types and Functions</a><ul class="internal"><li><a class="tocitem" href="#Flexible-Multivariate-Linear-Mixed-Models-(flxMLMM)"><span>Flexible Multivariate Linear Mixed Models (flxMLMM)</span></a></li><li><a class="tocitem" href="#Genetic-Relatedness-Matrices-(GRM)"><span>Genetic Relatedness Matrices (GRM)</span></a></li><li><a class="tocitem" href="#Visualization-(QTLplot)"><span>Visualization (QTLplot)</span></a></li><li><a class="tocitem" href="#Multivariate-Linear-Models-(MLM)"><span>Multivariate Linear Models (MLM)</span></a></li><li><a class="tocitem" href="#Utility-Functions-(Util)"><span>Utility Functions (Util)</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Types and Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Types and Functions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/hkim89/FlxQTL.jl/blob/master/docs/src/functions.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Functions-and-Types"><a class="docs-heading-anchor" href="#Functions-and-Types">Functions and Types</a><a id="Functions-and-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Functions-and-Types" title="Permalink"></a></h1><h2 id="Flexible-Multivariate-Linear-Mixed-Models-(flxMLMM)"><a class="docs-heading-anchor" href="#Flexible-Multivariate-Linear-Mixed-Models-(flxMLMM)">Flexible Multivariate Linear Mixed Models (flxMLMM)</a><a id="Flexible-Multivariate-Linear-Mixed-Models-(flxMLMM)-1"></a><a class="docs-heading-anchor-permalink" href="#Flexible-Multivariate-Linear-Mixed-Models-(flxMLMM)" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FlxQTL.FlxQTL" href="#FlxQTL.FlxQTL"><code>FlxQTL.FlxQTL</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia">FlxQTL</code></pre><p>flexible Multivariate Linear Mixed Model based QTL analysis tools for structured multiple traits. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hkim89/FlxQTL.jl/blob/615526a2916270405ea970ecd2c3243d494f2804/src/FlxQTL.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FlxQTL.flxMLMM" href="#FlxQTL.flxMLMM"><code>FlxQTL.flxMLMM</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia">flxMLMM</code></pre><p>A module designed for fitting a Multivariate Linear Mixed Model run by Nesterov&#39;s Accelerated Gradient  with restarting scheme incorporated with Expectation Conditional Maximization.</p><p>The model:</p><p><span>$Y=XBZ&#39;+R+E$</span>, where <span>$E(vec(Y))= (Z \otimes X)vec(B)$</span>,  <span>$var(vec(Y))= \tau^2 K_G \otimes K_C + I_n \otimes \Sigma$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hkim89/FlxQTL.jl/blob/615526a2916270405ea970ecd2c3243d494f2804/src/flxMLMM.jl#L2-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FlxQTL.flxMLMM.K2Eig" href="#FlxQTL.flxMLMM.K2Eig"><code>FlxQTL.flxMLMM.K2Eig</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">  K2Eig(Kg,Kc::Array{Float64,2},LOCO::Bool=false)</code></pre><p>Returns a two pairs of eigenvectors and eigenvalues for genetic and climatic relatedness matrices.  </p><p><strong>Arguments</strong></p><ul><li><code>Kg</code> : A matrix of a genetic kinship, or 3-d array of that if <code>LOCO</code> sets to be <code>true</code>.</li><li><code>Kc</code> : A matrix of a climatic relatedness.</li><li><code>LOCO</code> : Boolean. Default is <code>false</code> (no LOCO). (Leave One Chromosome Out). <code>LOCO</code> is only connected to the genetic kinship (<code>Kg</code>).</li></ul><p><strong>Output</strong></p><ul><li><code>Tg</code> : A matrix of eigenvectors for <code>Kg</code>, or 3-d array of eigenvectors if <code>LOCO</code> sets to be <code>true</code>. </li><li><code>λg</code> : A vector of eigenvalues for <code>Kg</code>, or matrix of eigenvalues if <code>LOCO</code> sets to be <code>true</code>. </li><li><code>Tc</code> : A matrix of eigenvectors for <code>Kc</code>.</li><li><code>λc</code> : A vector of eigenvalues for <code>Kc</code></li></ul><p>See <a href="#FlxQTL.flxMLMM.K2eig"><code>K2eig</code></a>.</p><p><strong>Examples</strong></p><p>For a genetic kinship calculated under <code>LOCO</code> (3-d array of kinship),</p><pre><code class="language-none"> Tg,λg,Tc,λc = K2Eig(Kg,Kc,true)
</code></pre><p>produces a 3-d array of <code>Tg</code>, matrices of <code>λg</code>, <code>Tc</code>, and a vector of <code>λc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hkim89/FlxQTL.jl/blob/615526a2916270405ea970ecd2c3243d494f2804/src/transformation.jl#L71-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FlxQTL.flxMLMM.K2eig" href="#FlxQTL.flxMLMM.K2eig"><code>FlxQTL.flxMLMM.K2eig</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">   K2eig(K,LOCO::Bool=false)</code></pre><p>Returns eigenvectors and eigenvalues of a (genetic, climatic) relatedness, or 3-d array of these of a genetic relatedness if <code>LOCO</code> is <code>true</code>. </p><p><strong>Arguments</strong></p><ul><li><code>K</code> : A matrix of (genetic or climatic) relatedness (Default).  3-d array of genetic relatedness (<code>LOCO</code> sets to be true.) </li><li><code>LOCO</code> : Boolean. Default is <code>false</code> (no LOCO). (Leave One Chromosome Out).</li></ul><p><strong>Output</strong></p><ul><li><code>T</code> : A matrix of eigenvectors, or 3-d array of eigenvectors if <code>LOCO</code> sets to be <code>true</code>. </li><li><code>λ</code> : A vector of eigenvalues, or matrix of eigenvalues if <code>LOCO</code> sets to be <code>true</code>. </li></ul><p>See also <a href="#FlxQTL.flxMLMM.K2Eig"><code>K2Eig</code></a>.</p><p><strong>Examples</strong></p><p>For a (climatic) relatedness, or genetic relatedness for <code>LOCO =false</code>,</p><pre><code class="language-none"> T, λ = K2eig(K)
</code></pre><p>produces a matrix of <code>T</code> and a vector of <code>λ</code>.</p><p>For a genetic kinship calculated under <code>LOCO</code> (3-d array of kinship),</p><pre><code class="language-none"> T, λ = K2eig(K,true)
</code></pre><p>produces a 3-d array of <code>T</code> and a matrix of <code>λ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hkim89/FlxQTL.jl/blob/615526a2916270405ea970ecd2c3243d494f2804/src/transformation.jl#L17-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FlxQTL.flxMLMM.gene2Scan" href="#FlxQTL.flxMLMM.gene2Scan"><code>FlxQTL.flxMLMM.gene2Scan</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">gene2Scan(cross::Int64,Tg,Tc::Array{Float64,2},Λg,λc::Array{Float64,1},
    Y0::Array{Float64,2},XX::Markers,Z0::Array{Float64,2},LOCO::Bool=false;ρ=0.001,Xnul::Array{Float64,2}=ones(1,size(Y0,2))
    ,itol=1e-4,tol0=1e-3,tol::Float64=1e-4)
gene2Scan(cross::Int64,Tg,Λg,Y0::Array{Float64,2},XX::Markers,LOCO::Bool=false;
                  Xnul::Array{Float64,2}=ones(1,size(Y0,2)),itol=1e-4,tol0=1e-3,tol::Float64=1e-4,ρ=0.001)</code></pre><p>Implement 2d-genome scan with/without LOCO (Leave One Chromosome Out). Note that the second <code>gene2Scan()</code> is based on a conventional MLMM: </p><div>\[vec(Y) \sim MVN((Z \otimes X)vec(B) (or XBZ&#39;) , K \otimes \Sigma_1 +I \otimes \Sigma_2),\]</div><p>where <code>K</code> is a genetic kinship, <span>$\Sigma_1, \Sigma_2$</span> are covariance matrices for  random and error terms, respectively.  <code>Z</code> can be replaced with an identity matrix.</p><p><strong>Arguments</strong></p><ul><li><code>cross</code> : An integer indicating the number of alleles or genotypes. Ex. 2 for RIF, 4 for four-way cross, 8 for HS mouse (allele probabilities), etc.         This value is related to degree of freedom when doing genome scan.</li><li><code>Tg</code> : A n x n matrix of eigenvectors from <a href="#FlxQTL.flxMLMM.K2eig"><code>K2eig</code></a>, or <a href="#FlxQTL.flxMLMM.K2Eig"><code>K2Eig</code></a>.       Returns 3d-array of eigenvectors as many as Chromosomes if <code>LOCO</code> is true.</li><li><code>Tc</code> : A m x m matrix of eigenvectors from climatic relatedness matrix. </li><li><code>Λg</code> : A n x 1 vector of eigenvalues from kinship. Returns a matrix of eigenvalues if <code>LOCO</code> is true.</li><li><code>λc</code> : A m x 1 vector of eigenvalues from climatic relatedness matrix. Use <code>ones(m)</code> for no climatic information added.</li><li><code>Y0</code> : A m x n matrix of response variables, i.e. m traits (or environments) by n individuals (or lines). For univariate phenotypes, use square brackets in arguement.       i.e. <code>Y0[1,:]</code> (a vector) -&gt; <code>Y[[1],:]</code> (a matrix) .</li><li><code>XX</code> : A type of <a href="#FlxQTL.Util.Markers"><code>Markers</code></a>.</li><li><code>Z0</code> :  An optional m x q matrix of low-dimensional phenotypic covariates, i.e. contrasts, basis functions (fourier, wavelet, polynomials, B-splines, etc.).      If nothing to insert in <code>Z0</code>, just insert an identity matrix, <code>Matrix(1.0I,m,m)</code>.  m traits x q phenotypic covariates. </li><li><code>LOCO</code> : Boolean. Default is <code>false</code> (no LOCO). Runs genome scan using LOCO (Leave One Chromosome Out).</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>Xnul</code> :  A matrix of covariates. Default is intercepts (1&#39;s).  Unless plugging in particular covariates, just leave as it is.</li><li><code>itol</code> :  A tolerance controlling ECM (Expectation Conditional Maximization) under H0: no QTL. Default is <code>1e-3</code>.</li><li><code>tol0</code> :  A tolerance controlling ECM under H1: existence of QTL. Default is <code>1e-3</code>.</li><li><code>tol</code> : A tolerance of controlling Nesterov Acceleration Gradient method under both H0 and H1. Default is <code>1e-4</code>.</li><li><code>ρ</code> : A tunning parameter controlling <span>$\tau^2$</span>. Default is <code>0.001</code>.  </li></ul><p>!!! Note</p><ul><li>When some LOD scores return negative values, reduce tolerences for ECM to <code>tol0 = 1e-4</code>. It works in most cases. If not,    can reduce both <code>tol0</code> and <code>tol</code> to <code>1e-4</code> or further.</li></ul><p><strong>Output</strong></p><ul><li><code>LODs</code> : LOD scores. Can change to <span>$- \log_{10}{P}$</span> using <a href="#FlxQTL.Util.lod2logP-Tuple{Union{Array{Any,1}, Array{Float64,1}},Int64}"><code>lod2logP</code></a>.</li><li><code>est0</code> : A type of <code>EcmNestrv.Approx</code> including parameter estimates under H0: no QTL. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hkim89/FlxQTL.jl/blob/615526a2916270405ea970ecd2c3243d494f2804/src/geneScan2D.jl#L78-L129">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FlxQTL.flxMLMM.geneScan" href="#FlxQTL.flxMLMM.geneScan"><code>FlxQTL.flxMLMM.geneScan</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">geneScan(cross::Int64,Tg,Tc::Array{Float64,2},Λg,λc::Array{Float64,1},Y0::Array{Float64,2},XX::Markers,Z0::Array{Float64,2},LOCO::Bool=false;
            Xnul::Array{Float64,2}=ones(1,size(Y0,2)),itol=1e-3,tol0=1e-3,tol::Float64=1e-4,ρ=0.001)
geneScan(cross::Int64,Tg,Tc::Array{Float64,2},Λg,λc::Array{Float64,1},Y0::Array{Float64,2},XX::Markers,LOCO::Bool=false;
            Xnul::Array{Float64,2}=ones(1,size(Y0,2)),itol=1e-3,tol0=1e-3,tol::Float64=1e-4,ρ=0.001)
geneScan(cross::Int64,Tg,Λg,Y0::Array{Float64,2},XX::Markers,LOCO::Bool=false;
    Xnul::Array{Float64,2}=ones(1,size(Y0,2)),itol=1e-3,tol0=1e-3,tol::Float64=1e-4,ρ=0.001)</code></pre><p>Implement 1d-genome scan with/without LOCO (Leave One Chromosome Out).  Note that the third <code>geneScan()</code> is based on a conventional MLMM: </p><div>\[vec(Y) \sim MVN((Z \otimes X)vec(B) (or XBZ&#39;),  K \otimes \Sigma_1 +I \otimes \Sigma_2),\]</div><p>where <code>K</code> is a genetic kinship,  <span>$\Sigma_1, \Sigma_2$</span> are covariance matrices for  random and error terms, respectively.  <code>Z</code> can be replaced with an identity matrix.</p><p><strong>Arguments</strong></p><ul><li><code>cross</code> : An integer indicating the number of alleles or genotypes. Ex. 2 for RIF, 4 for four-way cross, 8 for HS mouse (allele probabilities), etc.         This value is related to degree of freedom when doing genome scan.</li><li><code>Tg</code> : A n x n matrix of eigenvectors from <a href="#FlxQTL.flxMLMM.K2eig"><code>K2eig</code></a>, or <a href="#FlxQTL.flxMLMM.K2Eig"><code>K2Eig</code></a>.       Returns 3d-array of eigenvectors as many as Chromosomes if <code>LOCO</code> is true.</li><li><code>Tc</code> : A m x m matrix of eigenvectors from climatic relatedness matrix. </li><li><code>Λg</code> : A n x 1 vector of eigenvalues from kinship. Returns a matrix of eigenvalues if <code>LOCO</code> is true.</li><li><code>λc</code> : A m x 1 vector of eigenvalues from climatic relatedness matrix. Use <code>ones(m)</code> for no climatic information added.</li><li><code>Y0</code> : A m x n matrix of response variables, i.e. m traits (or environments) by n individuals (or lines). For univariate phenotypes, use square brackets in arguement.       i.e. <code>Y0[1,:]</code> (a vector) -&gt;<code>Y[[1],:]</code> (a matrix) .</li><li><code>XX</code> : A type of <a href="#FlxQTL.Util.Markers"><code>Markers</code></a>.</li><li><code>Z0</code> :  An optional m x q matrix of low-dimensional phenotypic covariates, i.e. contrasts, basis functions (fourier, wavelet, polynomials, B-splines, etc.).      If nothing to insert in <code>Z0</code>, just exclude it or insert an identity matrix, <code>Matrix(1.0I,m,m)</code>.  m traits x q phenotypic covariates. </li><li><code>LOCO</code> : Boolean. Default is <code>false</code> (no LOCO). Runs genome scan using LOCO (Leave One Chromosome Out).</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>Xnul</code> :  A matrix of covariates. Default is intercepts (1&#39;s).  Unless plugging in particular covariates, just leave as it is.</li><li><code>itol</code> :  A tolerance controlling ECM (Expectation Conditional Maximization) under H0: no QTL. Default is <code>1e-3</code>.</li><li><code>tol0</code> :  A tolerance controlling ECM under H1: existence of QTL. Default is <code>1e-3</code>.</li><li><code>tol</code> : A tolerance of controlling Nesterov Acceleration Gradient method under both H0 and H1. Default is <code>1e-4</code>.</li><li><code>ρ</code> : A tunning parameter controlling <span>$\tau^2$</span>. Default is <code>0.001</code>.  </li></ul><p>!!! Note</p><ul><li>When some LOD scores return negative values, reduce tolerences for ECM to <code>tol0 = 1e-4</code>. It works in most cases. If not,    can reduce both <code>tol0</code> and <code>tol</code> to <code>1e-4</code> or further.</li></ul><p><strong>Output</strong></p><ul><li><code>LODs</code> : LOD scores. Can change to <span>$- \log_{10}{P}$</span> in <a href="#FlxQTL.Util.lod2logP-Tuple{Union{Array{Any,1}, Array{Float64,1}},Int64}"><code>lod2logP</code></a>.</li><li><code>B</code> : A 3-d array of <code>B</code> (fixed effects) matrices under H1: existence of QTL. </li><li><code>est0</code> : A type of <code>EcmNestrv.Approx</code> including parameter estimates under H0: no QTL. </li><li><code>X1,Y1,(or Z1)</code> : transformed <code>XX.X, Y0, (or Z0)</code> by <code>Tg, Tc</code> to use permutation test.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hkim89/FlxQTL.jl/blob/615526a2916270405ea970ecd2c3243d494f2804/src/geneScan1D.jl#L97-L153">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FlxQTL.flxMLMM.permTest-Tuple{Int64,Any,Any,Any,Any,Markers,Any}" href="#FlxQTL.flxMLMM.permTest-Tuple{Int64,Any,Any,Any,Any,Markers,Any}"><code>FlxQTL.flxMLMM.permTest</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">  permTest(nperm,cross,Kg,Kc,Y0,XX::Markers,Z0;pval=[0.05 0.01],Xnul=ones(1,size(Y0,2)),itol=1e-4,tol0=1e-3,tol=1e-4,ρ=0.001)
  permTest(nperm,cross,Kg,Y0,XX::Markers;pval=[0.05 0.01],Xnul=ones(1,size(Y0,2)),itol=1e-4,tol0=1e-3,tol=1e-4,ρ=0.001)</code></pre><p>Implement permutation test to get thresholds at the levels of type 1 error, <code>α</code>.  Note that the second <code>permTest()</code> is for the conventional MLMM: </p><div>\[vec(Y)\sim MVN((I \otimes X)vec(B) (or BX), K \otimes \Sigma_1 +I \otimes \Sigma_2),\]</div><p>where <code>K</code> is a genetic kinship, <span>$\Sigma_1, \Sigma_2$</span> are covariance matrices for random and error terms, respectively.</p><p><strong>Arguments</strong></p><ul><li><code>nperm</code> : An integer indicating the number of permutation to be implemented.</li><li><code>cross</code> : An integer indicating the number of alleles or genotypes. Ex. <code>2</code> for RIF, <code>4</code> for four-way cross, <code>8</code> for HS mouse (allele probabilities), etc.         This value is related to degree of freedom when doing genome scan.</li><li><code>Kg</code> : A n x n genetic kinship matrix. Should be symmetric positive definite.</li><li><code>Kc</code> : A m x m climatic relatedness matrix. Should be symmetric positive definite.</li><li><code>Y0</code> : A m x n matrix of response variables, i.e. m traits (or environments) by n individuals (or lines). For univariate phenotypes, use square brackets in arguement.       i.e. <code>Y0[1,:]</code>  (a vector) -&gt; <code>Y[[1],:]</code>  (a matrix) .</li><li><code>XX</code> : A type of <a href="#FlxQTL.Util.Markers"><code>Markers</code></a>.</li><li><code>Z0</code> : An optional m x q matrix of low-dimensional phenotypic covariates, i.e. contrasts, basis functions (fourier, wavelet, polynomials, B-splines, etc.).      If nothing to insert in <code>Z0</code>, just insert an identity matrix, <code>Matrix(1.0I,m,m)</code>.  <code>m</code> traits x <code>q</code> phenotypic covariates. </li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>pval</code> : A vector of p-values to get their quantiles. Default is <code>[0.05  0.01]</code> (without comma).</li><li><code>Xnul</code> : A matrix of covariates. Default is intercepts (1&#39;s).  Unless plugging in particular covariates, just leave as it is.</li><li><code>itol</code> : A tolerance controlling ECM (Expectation Conditional Maximization) under H0: no QTL. Default is <code>1e-3</code>.</li><li><code>tol0</code> : A tolerance controlling ECM under H1: existence of QTL. Default is <code>1e-3</code>.</li><li><code>tol</code> : A tolerance of controlling Nesterov Acceleration Gradient method under both H0 and H1. Default is <code>1e-4</code>.</li><li><code>ρ</code> : A tunning parameter controlling <span>$\tau^2$</span>. Default is <code>0.001</code>.  </li></ul><p><strong>Output</strong></p><ul><li><code>maxLODs</code> : A nperm x 1 vector of maximal LOD scores by permutation. </li><li><code>H1par_perm</code> : A type of struct, <code>EcmNestrv.Approx(B,τ2,Σ,loglik)</code> including parameter estimates  or <code>EcmNestrv.Result(B,Vc,Σ,loglik)</code>                for a conventional MLMM under H0: no QTL by permutation. </li><li><code>cutoff</code> : A vector of thresholds corresponding to <code>pval</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hkim89/FlxQTL.jl/blob/615526a2916270405ea970ecd2c3243d494f2804/src/permutationTest.jl#L129-L170">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FlxQTL.EcmNestrv" href="#FlxQTL.EcmNestrv"><code>FlxQTL.EcmNestrv</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia">EcmNestrv</code></pre><p>A module for base algorithms using ECM (Expectation-Conditional Maxization) with Speed restarting Nesterov&#39;s accelerated gradient method  to fit a flexible multivariate linear mixed model (flxMLMM).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hkim89/FlxQTL.jl/blob/615526a2916270405ea970ecd2c3243d494f2804/src/EcmNestrv.jl#L1-L8">source</a></section></article><h2 id="Genetic-Relatedness-Matrices-(GRM)"><a class="docs-heading-anchor" href="#Genetic-Relatedness-Matrices-(GRM)">Genetic Relatedness Matrices (GRM)</a><a id="Genetic-Relatedness-Matrices-(GRM)-1"></a><a class="docs-heading-anchor-permalink" href="#Genetic-Relatedness-Matrices-(GRM)" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FlxQTL.GRM" href="#FlxQTL.GRM"><code>FlxQTL.GRM</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia"> GRM</code></pre><p>A module for computing Genetic Relatedness Matrix (or kinship).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hkim89/FlxQTL.jl/blob/615526a2916270405ea970ecd2c3243d494f2804/src/GRM.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FlxQTL.GRM.kinship4way-Tuple{Array{Float64,2}}" href="#FlxQTL.GRM.kinship4way-Tuple{Array{Float64,2}}"><code>FlxQTL.GRM.kinship4way</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia"> kinship4way(genmat::Array{Float64,2})</code></pre><p>Computes a kinship for four-way cross data counting different alleles between two markers: ex. AB-AB=0; AB-AC=1; AB-CD=2,<span>$\dots$</span> Note: In <a href="https://cran.r-project.org/web/packages/qtl/qtl.pdf">R/qtl</a>, genotypes are labeled as 1=AC; 2=BC; 3=AD; 4=BD by the function, <code>read.cross</code>.</p><p><strong>Argument</strong></p><ul><li><code>genmat</code> : A matrix of genotypes for <code>four-way cross</code> <span>$(1,2, \dots)$</span>.           size(genematrix)= (p,n), for <code>p</code> genetic markers x <code>n</code> individuals(or lines).</li></ul><p><strong>Output</strong></p><p>Returns a n x n symmetric matrix containing 1&#39;s on the diagonal. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hkim89/FlxQTL.jl/blob/615526a2916270405ea970ecd2c3243d494f2804/src/GRM.jl#L63-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FlxQTL.GRM.kinshipCtr-Tuple{Array{Float64,2}}" href="#FlxQTL.GRM.kinshipCtr-Tuple{Array{Float64,2}}"><code>FlxQTL.GRM.kinshipCtr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia"> kinshipCtr(genmat::Array{Float64,2})</code></pre><p>Calculates a kinship by a centered genotype matrix (linear kernel), i.e. genotypes subtracted by marker mean.</p><p><strong>Argument</strong></p><ul><li><code>genmat</code> : A matrix of genotype data (0,1,2). size(genmat)=(p,n) for <code>p</code> markers x <code>n</code> individuals</li></ul><p><strong>Output</strong></p><p>Returns a n x n symmetric matrix. See also <a href="#FlxQTL.GRM.kinshipStd-Tuple{Array{Float64,2}}"><code>kinshipStd</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hkim89/FlxQTL.jl/blob/615526a2916270405ea970ecd2c3243d494f2804/src/GRM.jl#L173-L188">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FlxQTL.GRM.kinshipGs-Tuple{Array{Float64,2},Float64}" href="#FlxQTL.GRM.kinshipGs-Tuple{Array{Float64,2},Float64}"><code>FlxQTL.GRM.kinshipGs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia"> kinshipGs(climate::Array{Float64,2},ρ::Float64)</code></pre><p>Computes a kinship matrix using the Gaussian Kernel.  </p><p><strong>Arguments</strong></p><ul><li><code>climate</code> : A matrix of genotype, or climate information data. size(climate)=(r,m), such that <code>r</code> genotype markers (or days/years of climate factors,            i.e. precipitations, temperatures, etc.), and <code>m</code> individuals (or environments/sites)</li><li><code>ρ</code> : A free parameter determining the width of the kernel. Could be attained empirically.  </li></ul><p><strong>Output</strong></p><p>Returns a m x m symmetric (positive definite) matrix containing 1&#39;s on the diagonal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hkim89/FlxQTL.jl/blob/615526a2916270405ea970ecd2c3243d494f2804/src/GRM.jl#L110-L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FlxQTL.GRM.kinshipLin-Tuple{Any,Any}" href="#FlxQTL.GRM.kinshipLin-Tuple{Any,Any}"><code>FlxQTL.GRM.kinshipLin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">kinshipLin(mat,cross)</code></pre><p>Calculates a kinship (or climatic relatedness, <a href="#FlxQTL.GRM.kinshipGs-Tuple{Array{Float64,2},Float64}"><code>kinshipGs</code></a>) matrix by linear kernel. </p><p><strong>Arguments</strong></p><ul><li><code>mat</code> : A matrix of genotype (or allele) probabilities usually extracted from <a href="https://rqtl.org/tutorials/rqtltour.pdf">R/qtl</a>,        <a href="https://kbroman.org/qtl2/assets/vignettes/user_guide.html">R/qtl2</a>, or the counterpart packages. size(mat)= (p,n) for p genetic markers x n individuals. </li><li><code>cross</code> : A scalar indicating the number of alleles or genotypes. ex. 2 for RIF, 4 for four-way cross, 8 for HS mouse (allele probabilities), etc.         This value is related to degree of freedom when doing genome scan.</li></ul><p><strong>Output</strong></p><p>Returns a n x n symmetric (positive definite) matrix containing 1&#39;s on the diagonal. </p><p>See also <a href="#FlxQTL.GRM.kinshipCtr-Tuple{Array{Float64,2}}"><code>kinshipCtr</code></a>, <a href="#FlxQTL.GRM.kinshipStd-Tuple{Array{Float64,2}}"><code>kinshipStd</code></a> for genetype data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hkim89/FlxQTL.jl/blob/615526a2916270405ea970ecd2c3243d494f2804/src/GRM.jl#L141-L161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FlxQTL.GRM.kinshipLoco" href="#FlxQTL.GRM.kinshipLoco"><code>FlxQTL.GRM.kinshipLoco</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia"> kinshipLoco(kin,g::Markers)</code></pre><p>Generates a 3-d array of symmetric positive definite kinship matrices using LOCO (Leave One Chromosome Out) witout shrinkage intensity estimation.   For a non-positive definite kinship, a tweak like a weighted average of kinship and Identity is used to correct minuscule negative eigenvalues. </p><p><strong>Arguments</strong></p><ul><li><code>kin</code> :  A function of computing a kinship. Can only use with <a href="#FlxQTL.GRM.kinshipCtr-Tuple{Array{Float64,2}}"><code>kinshipCtr</code></a>, <a href="#FlxQTL.GRM.kinshipStd-Tuple{Array{Float64,2}}"><code>kinshipStd</code></a></li><li><code>g</code> : A struct of arrays, type  <a href="#FlxQTL.Util.Markers"><code>Markers</code></a>.</li></ul><p><strong>Output</strong></p><p>Returns 3-d array of <code>C</code> n x n symmetric positive definite matrices for <code>C</code> Chromosomes. Refer to <a href="#FlxQTL.GRM.shrinkgLoco-Tuple{Any,Int64,Markers}"><code>shrinkgLoco</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hkim89/FlxQTL.jl/blob/615526a2916270405ea970ecd2c3243d494f2804/src/GRM.jl#L359-L376">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FlxQTL.GRM.kinshipMan-Tuple{Array{Float64,2}}" href="#FlxQTL.GRM.kinshipMan-Tuple{Array{Float64,2}}"><code>FlxQTL.GRM.kinshipMan</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">  kinshipMan(genematrix::Array{Float64,2})</code></pre><p>Calculates a kinship matrix using a manhattan distance. Missing values need to be either omitted or imputed.  This function is not for 4-way cross genotype data.  See <a href="#FlxQTL.GRM.kinship4way-Tuple{Array{Float64,2}}"><code>kinship4way</code></a>.</p><p><strong>Argument</strong></p><ul><li><code>genematrix</code> : A matrix of genotypes, i.e. 0,1,2.  size(genematrix)= (p,n) for <code>p</code> genetic markers x <code>n</code> individuals(or lines).</li></ul><p><strong>Output</strong></p><p>Returns a n x n symmetric matrix containing 1&#39;s on the diagonal. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hkim89/FlxQTL.jl/blob/615526a2916270405ea970ecd2c3243d494f2804/src/GRM.jl#L23-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FlxQTL.GRM.kinshipStd-Tuple{Array{Float64,2}}" href="#FlxQTL.GRM.kinshipStd-Tuple{Array{Float64,2}}"><code>FlxQTL.GRM.kinshipStd</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia"> kinshipStd(genmat::Array{Float64,2})</code></pre><p>Calculates a kinship by a standardized (or normalized) genotype matrix (linear kernel), i.e. genotypes subtracted by marker mean and divided by marker standard deviation.   Can also do with climatic information data. See <a href="#FlxQTL.GRM.kinshipGs-Tuple{Array{Float64,2},Float64}"><code>kinshipGs</code></a>.</p><p><strong>Argument</strong></p><ul><li><code>genmat</code> : A matrix of genotype data (0,1,2). size(genmat)=(p,n) for <code>p</code> markers x <code>n</code> individuals</li></ul><p><strong>Output</strong></p><p>Returns a n x n symmetric matrix. See also <a href="#FlxQTL.GRM.kinshipCtr-Tuple{Array{Float64,2}}"><code>kinshipCtr</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hkim89/FlxQTL.jl/blob/615526a2916270405ea970ecd2c3243d494f2804/src/GRM.jl#L200-L217">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FlxQTL.GRM.shrinkg-Tuple{Any,Int64,Any}" href="#FlxQTL.GRM.shrinkg-Tuple{Any,Int64,Any}"><code>FlxQTL.GRM.shrinkg</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia"> shrinkg(f,nb::Int64,geno)</code></pre><p>Estimates a full-rank positive definite kinship matrix by shrinkage intensity estimation (bootstrap).  Can only use with <a href="#FlxQTL.GRM.kinshipMan-Tuple{Array{Float64,2}}"><code>kinshipMan</code></a>, <a href="#FlxQTL.GRM.kinship4way-Tuple{Array{Float64,2}}"><code>kinship4way</code></a>. This function runs faster by CPU parallelization.  Add workers/processes using <code>addprocs()</code> function before running. </p><p><strong>Arguments</strong></p><ul><li><code>f</code>: A function of computing a kinship. Can only use with <a href="#FlxQTL.GRM.kinshipMan-Tuple{Array{Float64,2}}"><code>kinshipMan</code></a>, <a href="#FlxQTL.GRM.kinship4way-Tuple{Array{Float64,2}}"><code>kinship4way</code></a>.</li><li><code>nb</code> : An integer indicating the number of bootstrap. It does not have to be a large number.  </li><li><code>geno</code> : A matrix of genotypes</li></ul><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; using flxQTL
julia&gt; addprocs(8) 
julia&gt; K = shinkage(kinshipMan,20,myGeno)</code></pre><p><strong>Output</strong></p><p>Returns a full-rank symmetric positive definite matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hkim89/FlxQTL.jl/blob/615526a2916270405ea970ecd2c3243d494f2804/src/GRM.jl#L230-L255">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FlxQTL.GRM.shrinkgLoco-Tuple{Any,Int64,Markers}" href="#FlxQTL.GRM.shrinkgLoco-Tuple{Any,Int64,Markers}"><code>FlxQTL.GRM.shrinkgLoco</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">   shrinkgLoco(kin,nb,g::Markers)</code></pre><p>Generates 3-d array of full-rank positive definite kinship matrices by shrinkage intensity estimation (bootstrap) using a LOCO (Leave One Chromosome Out) scheme.</p><p><strong>Argument</strong></p><ul><li><code>kin</code> :  A function of computing a kinship. Can only use with <a href="#FlxQTL.GRM.kinshipMan-Tuple{Array{Float64,2}}"><code>kinshipMan</code></a>, <a href="#FlxQTL.GRM.kinship4way-Tuple{Array{Float64,2}}"><code>kinship4way</code></a></li><li><code>nb</code> : An integer indicating the number of bootstrap.</li><li><code>g</code> : A struct of arrays, type <a href="#FlxQTL.Util.Markers"><code>Markers</code></a>.</li></ul><p><strong>Output</strong></p><p>Returns 3-d array of <code>C</code> n x n symmetric positive definite matrices for <code>C</code> Chromosomes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hkim89/FlxQTL.jl/blob/615526a2916270405ea970ecd2c3243d494f2804/src/GRM.jl#L317-L336">source</a></section></article><h2 id="Visualization-(QTLplot)"><a class="docs-heading-anchor" href="#Visualization-(QTLplot)">Visualization (QTLplot)</a><a id="Visualization-(QTLplot)-1"></a><a class="docs-heading-anchor-permalink" href="#Visualization-(QTLplot)" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FlxQTL.QTLplot" href="#FlxQTL.QTLplot"><code>FlxQTL.QTLplot</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia"> QTLplot</code></pre><p>A module for generating PyPlot-based 1D-, 2D-plots for LOD scores (or effects).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hkim89/FlxQTL.jl/blob/615526a2916270405ea970ecd2c3243d494f2804/src/QTLplot.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FlxQTL.QTLplot.layers" href="#FlxQTL.QTLplot.layers"><code>FlxQTL.QTLplot.layers</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">layers(chr::Array{Any,1},pos::Array{Float64,1},lod::Array{Float64,2})</code></pre><p>Creates a struct of arrays for plotting LOD scores, (or main, interaction) effects</p><p><strong>Argument</strong></p><ul><li><code>chr</code> : A vector of strings or numbers indicating Chromosome names, ex. 1,2,3,... or 1K,1N,2K,2N,...</li><li><code>pos</code> : A vector of marker positions</li><li><code>lod</code> : A matrix of LOD scores obtained from 1d- or 2d-genome scan.  Can be a matrix of effects (main, or interaction).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hkim89/FlxQTL.jl/blob/615526a2916270405ea970ecd2c3243d494f2804/src/QTLplot.jl#L14-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FlxQTL.QTLplot.plot1d-Tuple{layers}" href="#FlxQTL.QTLplot.plot1d-Tuple{layers}"><code>FlxQTL.QTLplot.plot1d</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">  plot1d(xx::layers;title= &quot; &quot;,ylabel=&quot;LOD&quot;,yint=[],yint_color=[&quot;red&quot;],Legend=[],loc=&quot;upper right&quot;)</code></pre><p>Generates one or more graphs of LOD scores (or effects) obtained from 1d-genome scan on a single plot.</p><p><strong>Arguments</strong></p><ul><li><code>xx</code> : A type of <a href="#FlxQTL.QTLplot.layers"><code>layers</code></a> that consists of chromosome names, marker positions, and a matrix of LODs(or effects).</li></ul><p><strong>Keyword arguements,</strong></p><ul><li><code>title</code> : A string of title. Default is blank.</li><li><code>yint</code> :  A vector of y-intercept(s)</li><li><code>yint_color</code> : A vector of colors (strings) of y-intercepts in yint</li><li><code>Legend</code> : A vector of titles corresponding to graphs in <code>layers</code></li><li><code>loc</code> : A string of Legend&#39;s position. Default is &quot;upper right&quot;.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hkim89/FlxQTL.jl/blob/615526a2916270405ea970ecd2c3243d494f2804/src/QTLplot.jl#L34-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FlxQTL.QTLplot.plot2d-Tuple{layers}" href="#FlxQTL.QTLplot.plot2d-Tuple{layers}"><code>FlxQTL.QTLplot.plot2d</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">    plot2d(S::layers)</code></pre><p>Generates 2-d heatmap plots of LOD scores from 2d-genome scan</p><p><strong>Argument</strong></p><ul><li><code>S</code>: a type of &#39;layers&#39; that consists of chromosome names, marker positions, and a matrix of LODs.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hkim89/FlxQTL.jl/blob/615526a2916270405ea970ecd2c3243d494f2804/src/QTLplot.jl#L139-L149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FlxQTL.QTLplot.subplot2d-Tuple{layers,Int64}" href="#FlxQTL.QTLplot.subplot2d-Tuple{layers,Int64}"><code>FlxQTL.QTLplot.subplot2d</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia"> subplot2d(S::layers,sub_dim::Int64;label=&quot;Chromosome&quot;):</code></pre><p>Generates a matrix of 2-d heatmap subplots for LOD scores obtained from 2d-genome scan  </p><p><strong>Arguments</strong></p><ul><li><code>sub_dim</code>: A two digit integer, where the first digit (m) is the number of rows, the second (n) the number of columns.             It returns a m x n matrix of subplots</li><li><code>label</code>: A string of the title of each subplot. It concatenates each entry of S.chr. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hkim89/FlxQTL.jl/blob/615526a2916270405ea970ecd2c3243d494f2804/src/QTLplot.jl#L167-L180">source</a></section></article><h2 id="Multivariate-Linear-Models-(MLM)"><a class="docs-heading-anchor" href="#Multivariate-Linear-Models-(MLM)">Multivariate Linear Models (MLM)</a><a id="Multivariate-Linear-Models-(MLM)-1"></a><a class="docs-heading-anchor-permalink" href="#Multivariate-Linear-Models-(MLM)" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FlxQTL.MLM" href="#FlxQTL.MLM"><code>FlxQTL.MLM</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia">  MLM</code></pre><p>A module for fitting general Multivariate Linear Models motivated by functional data analysis via mle or reml. The default fitting method is mle. ( i.e. reml=false)</p><p>The model:  <span>$Y=XBZ&#39;+E$</span>, where <span>$E(Y)=XBZ&#39;$</span> (or <span>$E(vec(Y))= (Z \otimes X)vec(B)$</span> ),  <span>$var(vec(E))=\Sigma \otimes I.$</span> size(Y)=(n,m), size(X)=(n,p), size(Z)=(m,q).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hkim89/FlxQTL.jl/blob/615526a2916270405ea970ecd2c3243d494f2804/src/MLM.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FlxQTL.MLM.Estimat" href="#FlxQTL.MLM.Estimat"><code>FlxQTL.MLM.Estimat</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia"> Estimat(B::Array{Float64,2},Σ::Array{Float64,2},loglik::Float64)</code></pre><p>A struct of arrays for results by fitting a multivariate linear model,  <code>mGLM()</code>.   The results are <code>B</code>(fixed effects), <code>Σ</code> (m x m covariance matrix), <code>loglik</code>(a value of log-likelihood by mle or reml).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hkim89/FlxQTL.jl/blob/615526a2916270405ea970ecd2c3243d494f2804/src/MLM.jl#L189-L196">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FlxQTL.MLM.mGLM" href="#FlxQTL.MLM.mGLM"><code>FlxQTL.MLM.mGLM</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">  mGLM(Y::Array{Float64,2},X::Array{Float64,2},Z::Array{Float64,2},reml::Bool=false)
  mGLM(Y::Array{Float64,2},X::Array{Float64,2},reml::Bool=false)</code></pre><p>Fitting multivariate General Linear Models via MLE (or REML) and returns a type of a struct <code>Estimat</code>.  </p><p><strong>Arguments</strong></p><ul><li><code>Y</code> : A matrix of response variables, i.e. traits. size(Y)=(n,m) for n individuals x m traits</li><li><code>X</code> : A matrix of independent variables, i.e. genotypes or genotype probabilities including intercept or/and covariates. size(X)=(n,p) for n individuals x p markers      including intercept or/and covariates </li><li><code>Z</code> : An optional matrix of low-dimensional phenotypic covariates, i.e. contrasts, basis functions (fourier, wavelet, polynomials, B-splines, etc.).      If nothing to insert in <code>Z</code>, just exclude it or insert <code>Matrix(1.0I,m,m)</code>. size(Z)=(m,q) for m traits x q phenotypic covariates.</li><li><code>reml</code> : Boolean. Default is fitting the model via mle. Resitricted MLE is implemented if <code>true</code>. </li></ul><p><strong>Output</strong></p><p>Returns <a href="#FlxQTL.MLM.Estimat"><code>Estimat</code></a> .</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hkim89/FlxQTL.jl/blob/615526a2916270405ea970ecd2c3243d494f2804/src/MLM.jl#L81-L103">source</a></section></article><h2 id="Utility-Functions-(Util)"><a class="docs-heading-anchor" href="#Utility-Functions-(Util)">Utility Functions (Util)</a><a id="Utility-Functions-(Util)-1"></a><a class="docs-heading-anchor-permalink" href="#Utility-Functions-(Util)" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FlxQTL.Util" href="#FlxQTL.Util"><code>FlxQTL.Util</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia"> Util</code></pre><p>A module for utility functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hkim89/FlxQTL.jl/blob/615526a2916270405ea970ecd2c3243d494f2804/src/Miscellanea.jl#L2-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FlxQTL.Util.Markers" href="#FlxQTL.Util.Markers"><code>FlxQTL.Util.Markers</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Markers(name::Array{String,1},chr::Array{Any,1},pos::Array{Float64,1},X::Array{Float64,2})</code></pre><p>A struct of arrays creating genotype or genotype probability data for genome scan.</p><p><strong>Arguments</strong></p><ul><li><code>name</code> : A vector of marker names</li><li><code>chr</code>  : A vector of Chromosomes</li><li><code>pos</code>  : A vector of marker positions (cM)</li><li><code>X</code> : A matrix of genotypes or genotype probabilities</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hkim89/FlxQTL.jl/blob/615526a2916270405ea970ecd2c3243d494f2804/src/Miscellanea.jl#L56-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FlxQTL.Util.Y_huber-Tuple{Array{Float64,2}}" href="#FlxQTL.Util.Y_huber-Tuple{Array{Float64,2}}"><code>FlxQTL.Util.Y_huber</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Y_huber(Y::Array{Float64,2})</code></pre><p>Rescale Y (phenotype or trait data) to be less sensitive to outliers using by Huber loss function and MAD (median absolute deviation).  size(Y)=(m,n) for <code>m</code> trait and <code>n</code> individuals.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hkim89/FlxQTL.jl/blob/615526a2916270405ea970ecd2c3243d494f2804/src/Miscellanea.jl#L348-L355">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FlxQTL.Util.array2mat-Tuple{Int64,Array{Float64,3}}" href="#FlxQTL.Util.array2mat-Tuple{Int64,Array{Float64,3}}"><code>FlxQTL.Util.array2mat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia"> array2mat(cross::Int64,X0::Array{Float64,3})</code></pre><p>Returns a 3-d array to a matrix of genotype probabilities. size(X0)=(p,cross,n) –&gt; (p1,n), where <code>p1</code> = <code>cross*p</code> for <code>p</code> markers,  <code>cross</code> alleles or genotypes, and <code>n</code> individuals. See <a href="#FlxQTL.Util.mat2array-Tuple{Int64,Any}"><code>mat2array</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hkim89/FlxQTL.jl/blob/615526a2916270405ea970ecd2c3243d494f2804/src/Miscellanea.jl#L144-L152">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FlxQTL.Util.getFinoidx-Tuple{Array{Union{Missing, Float64},2}}" href="#FlxQTL.Util.getFinoidx-Tuple{Array{Union{Missing, Float64},2}}"><code>FlxQTL.Util.getFinoidx</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getFinoidx(phenoData::Array{Union{Missing,Float64},2})</code></pre><p>Attains indices of phenotype data without missing values.</p><p><strong>Argument</strong></p><ul><li><code>phenoData</code> : A matrix of phenotype (or trait) data including missing values. size(phenoData) = (m,n) for <code>m</code> traits and <code>n</code> individuals.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hkim89/FlxQTL.jl/blob/615526a2916270405ea970ecd2c3243d494f2804/src/Miscellanea.jl#L224-L234">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FlxQTL.Util.getGenoidx" href="#FlxQTL.Util.getGenoidx"><code>FlxQTL.Util.getGenoidx</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getGenoidx(GenoData::Array{Any,2},maf::Float64=0.025)</code></pre><p>Attains genotype indices to drop correlated or bad markers.</p><p><strong>Arguments</strong></p><ul><li><code>GenoData</code> : A matrix of genotype data. size(GenoData)= (p,n) for <code>p</code> markers and <code>n</code> individuals.</li><li><code>maf</code> : A scalar for dropping criterion of markers. Default is <code>0,025</code> i.e. markers of MAF &lt; 0.025 are dropped.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hkim89/FlxQTL.jl/blob/615526a2916270405ea970ecd2c3243d494f2804/src/Miscellanea.jl#L205-L215">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FlxQTL.Util.lod2logP-Tuple{Union{Array{Any,1}, Array{Float64,1}},Int64}" href="#FlxQTL.Util.lod2logP-Tuple{Union{Array{Any,1}, Array{Float64,1}},Int64}"><code>FlxQTL.Util.lod2logP</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">lod2logP(LODs::Union{Array{Float64,1},Array{Any,1}},v::Int64)</code></pre><p>Caculates <span>$-\log_{10}{P}$</span> from LOD scores.</p><p><strong>Arguments</strong></p><ul><li><code>LODs</code> : A vector of LOD scores computed from genome scan.</li><li><code>v</code> : A degree of freedom for Chi-squared distribution.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hkim89/FlxQTL.jl/blob/615526a2916270405ea970ecd2c3243d494f2804/src/Miscellanea.jl#L243-L254">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FlxQTL.Util.mat2array-Tuple{Int64,Any}" href="#FlxQTL.Util.mat2array-Tuple{Int64,Any}"><code>FlxQTL.Util.mat2array</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia"> mat2array(cross::Int64,X0)</code></pre><p>Returns a matrix of genotype probabilities to 3-d array. size(X0)=(p1,n) –&gt; (p,cross,n), where <code>p1</code> = <code>cross*p</code> for <code>p</code> markers,  <code>cross</code> alleles or genotypes, and <code>n</code> individuals.</p><p><strong>Argument</strong></p><ul><li><code>cross</code> : An integer indicating the number of alleles or genotypes. Ex. 2 for RIF, 4 for four-way cross, 8 for HS mouse (allele probabilities), etc.</li><li><code>X0</code> : A matrix of genotype probability data computed from r/qtl or r/qtl2.  </li></ul><p>See <a href="#FlxQTL.Util.array2mat-Tuple{Int64,Array{Float64,3}}"><code>array2mat</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hkim89/FlxQTL.jl/blob/615526a2916270405ea970ecd2c3243d494f2804/src/Miscellanea.jl#L119-L133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FlxQTL.Util.mat2vec-Tuple{Any}" href="#FlxQTL.Util.mat2vec-Tuple{Any}"><code>FlxQTL.Util.mat2vec</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia"> mat2vec(mat)</code></pre><p>Stacks a matrix to a vector, i.e. vectorizing a matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hkim89/FlxQTL.jl/blob/615526a2916270405ea970ecd2c3243d494f2804/src/Miscellanea.jl#L101-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FlxQTL.Util.newMarkers" href="#FlxQTL.Util.newMarkers"><code>FlxQTL.Util.newMarkers</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">newMarkers(XX::Markers,cross::Int64,cM::Int64=2)</code></pre><p>Returns a struct of Markers by keeping only markers positioned in every <code>cM</code> centimorgans for 2-d genome scan to avoid singularity.</p><p><strong>Arguments</strong></p><ul><li><code>XX</code> : A type of <code>Markers</code>. See <a href="#FlxQTL.Util.Markers"><code>Markers</code></a>.</li><li><code>cross</code> : An integer indicating the number of alleles or genotypes. Ex. 2 for RIF, 4 for four-way cross, 8 for HS mouse (allele probabilities), etc.</li><li><code>cM</code> : An integer of dropping criterion of markers. Default is 2, i.e. keeping only markers in every 2 cM, or dropping markers within 2cM between 2 markers.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hkim89/FlxQTL.jl/blob/615526a2916270405ea970ecd2c3243d494f2804/src/Miscellanea.jl#L309-L321">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FlxQTL.Util.ordrMarkers-Tuple{Array{Any,2}}" href="#FlxQTL.Util.ordrMarkers-Tuple{Array{Any,2}}"><code>FlxQTL.Util.ordrMarkers</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ordrMarkers(markers::Array{Any,2})</code></pre><p>Rearrange by CPU parallelization marker information composed of marker name, chr, position obtained from rqtl2, which is not listed in order (excluding <code>X</code> chromosome).</p><p><strong>Argument</strong></p><ul><li><code>markers</code> : An array of marker information.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hkim89/FlxQTL.jl/blob/615526a2916270405ea970ecd2c3243d494f2804/src/Miscellanea.jl#L79-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FlxQTL.Util.setSeed" href="#FlxQTL.Util.setSeed"><code>FlxQTL.Util.setSeed</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">setSeed(lw::Int64,up::Int64,replace::Bool=false)</code></pre><p>Assigns different numbers of seeds to workers (or processes).</p><p><strong>Arguments</strong></p><ul><li><code>lw</code> : A lower bound to set seeds.</li><li><code>up</code> : A upper bound to set seeds.</li><li><code>replace</code> : Sampling seed numbers between <code>lw</code> and <code>up</code> with/without replacement. Default is <code>false: without replacement</code>.          Since the function itself recognize the number of processes (or workers) and their id, a wider range of seed numbers needs to set for default.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; using Distributed
julia&gt; addprocs(10)
julia&gt; @everywhere using flxQTL
julia&gt; setSeed(1,20)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hkim89/FlxQTL.jl/blob/615526a2916270405ea970ecd2c3243d494f2804/src/Miscellanea.jl#L19-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FlxQTL.Util.sortBycM" href="#FlxQTL.Util.sortBycM"><code>FlxQTL.Util.sortBycM</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">    sortBycM(Chr::Any,XX::Markers,cross::Int64,cM::Int64=2)</code></pre><p>Returns marker indices in Chromosome <code>Chr</code> and the corresponding genotype probabilities keeping only markers positioned in every <code>cM</code> centimorgans  for 2-d genome scan to avoid singularity.</p><p><strong>Arguments</strong></p><ul><li><code>Chr</code> : A type of Any indicating a particular chromosome to sort markers out.</li><li><code>XX</code> : A type of <a href="#FlxQTL.Util.Markers"><code>Markers</code></a>.</li><li><code>cross</code> : An integer indicating the number of alleles or genotypes. Ex. 2 for RIF, 4 for four-way cross, 8 for HS mouse (allele probabilities), etc.</li><li><code>cM</code> : An integer of dropping criterion of markers. Default is 2, i.e. keeping only markers in every 2 cM, or dropping markers within 2cM between 2 markers.</li></ul><p>See also <a href="#FlxQTL.Util.newMarkers"><code>newMarkers</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hkim89/FlxQTL.jl/blob/615526a2916270405ea970ecd2c3243d494f2804/src/Miscellanea.jl#L263-L279">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../guide/analysis/">« QTL analysis</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 12 January 2021 04:50">Tuesday 12 January 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
