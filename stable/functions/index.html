<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Types and Functions · FlxQTL.jl</title><meta name="title" content="Types and Functions · FlxQTL.jl"/><meta property="og:title" content="Types and Functions · FlxQTL.jl"/><meta property="twitter:title" content="Types and Functions · FlxQTL.jl"/><meta name="description" content="Documentation for FlxQTL.jl."/><meta property="og:description" content="Documentation for FlxQTL.jl."/><meta property="twitter:description" content="Documentation for FlxQTL.jl."/><meta property="og:url" content="https://senresearch.github.io/FlxQTL.jl/stable/functions/"/><meta property="twitter:url" content="https://senresearch.github.io/FlxQTL.jl/stable/functions/"/><link rel="canonical" href="https://senresearch.github.io/FlxQTL.jl/stable/functions/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">FlxQTL.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../guide/tutorial/">Package Guide</a></li><li><a class="tocitem" href="../guide/analysis/">QTL Analysis</a></li><li class="is-active"><a class="tocitem" href>Types and Functions</a><ul class="internal"><li><a class="tocitem" href="#Flexible-Multivariate-Linear-Mixed-Models-(flxMLMM)"><span>Flexible Multivariate Linear Mixed Models (flxMLMM)</span></a></li><li><a class="tocitem" href="#Genetic-Relatedness-Matrices-(GRM)"><span>Genetic Relatedness Matrices (GRM)</span></a></li><li><a class="tocitem" href="#Flexible-Multivariate-Linear-Models-(flxMLM)"><span>Flexible Multivariate Linear Models (flxMLM)</span></a></li><li><a class="tocitem" href="#Utility-Functions-(Util)"><span>Utility Functions (Util)</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Types and Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Types and Functions</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/senresearch/FlxQTL.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/senresearch/FlxQTL.jl/blob/master/docs/src/functions.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Functions-and-Types"><a class="docs-heading-anchor" href="#Functions-and-Types">Functions and Types</a><a id="Functions-and-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Functions-and-Types" title="Permalink"></a></h1><h2 id="Flexible-Multivariate-Linear-Mixed-Models-(flxMLMM)"><a class="docs-heading-anchor" href="#Flexible-Multivariate-Linear-Mixed-Models-(flxMLMM)">Flexible Multivariate Linear Mixed Models (flxMLMM)</a><a id="Flexible-Multivariate-Linear-Mixed-Models-(flxMLMM)-1"></a><a class="docs-heading-anchor-permalink" href="#Flexible-Multivariate-Linear-Mixed-Models-(flxMLMM)" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FlxQTL.FlxQTL" href="#FlxQTL.FlxQTL"><code>FlxQTL.FlxQTL</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FlxQTL</code></pre><p>flexible QTL analysis tools for structured multiple traits fitting a Multivariate Linear Mixed Model or a Multivariate      Linear Model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/FlxQTL.jl/blob/e4cde72221f550a5f6fd55e03b603b53ed2096a7/src/FlxQTL.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FlxQTL.flxMLMM" href="#FlxQTL.flxMLMM"><code>FlxQTL.flxMLMM</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">flxMLMM</code></pre><p>A module designed for fitting a Multivariate Linear Mixed Model run by Nesterov&#39;s Accelerated Gradient with restarting scheme incorporated with Expectation Conditional Maximization to  estimate MLEs.  REML is not supported.</p><p>The model:</p><p><span>$Y=XBZ&#39;+R+E$</span>, where <span>$E(vec(Y))= (Z \otimes X)vec(B)$</span>,  <span>$var(vec(Y))= \tau^2 K_G \otimes K_C + I_n \otimes \Sigma$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/FlxQTL.jl/blob/e4cde72221f550a5f6fd55e03b603b53ed2096a7/src/flxMLMM.jl#L2-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FlxQTL.flxMLMM.K2Eig" href="#FlxQTL.flxMLMM.K2Eig"><code>FlxQTL.flxMLMM.K2Eig</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">  K2Eig(Kg,Kc::Array{Float64,2},LOCO::Bool=false)</code></pre><p>Returns a two pairs of eigenvectors and eigenvalues for genetic and climatic relatedness matrices.</p><p><strong>Arguments</strong></p><ul><li><code>Kg</code> : A matrix of a genetic kinship, or 3-d array of that if <code>LOCO</code> sets to be <code>true</code>.</li><li><code>Kc</code> : A matrix of a climatic relatedness.</li><li><code>LOCO</code> : Boolean. Default is <code>false</code> (no LOCO). (Leave One Chromosome Out). <code>LOCO</code> is only connected to the genetic kinship (<code>Kg</code>).</li></ul><p><strong>Output</strong></p><ul><li><code>Tg</code> : A matrix of eigenvectors for <code>Kg</code>, or 3-d array of eigenvectors if <code>LOCO</code> sets to be <code>true</code>.</li><li><code>λg</code> : A vector of eigenvalues for <code>Kg</code>, or matrix of eigenvalues if <code>LOCO</code> sets to be <code>true</code>.</li><li><code>Tc</code> : A matrix of eigenvectors for <code>Kc</code>.</li><li><code>λc</code> : A vector of eigenvalues for <code>Kc</code></li></ul><p>See <a href="#FlxQTL.flxMLMM.K2eig"><code>K2eig</code></a>.</p><p><strong>Examples</strong></p><p>For a genetic kinship calculated under <code>LOCO</code> (3-d array of kinship),</p><pre><code class="nohighlight hljs"> Tg,λg,Tc,λc = K2Eig(Kg,Kc,true)
</code></pre><p>produces a 3-d array of <code>Tg</code>, matrices of <code>λg</code>, <code>Tc</code>, and a vector of <code>λc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/FlxQTL.jl/blob/e4cde72221f550a5f6fd55e03b603b53ed2096a7/src/transformation.jl#L72-L104">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FlxQTL.flxMLMM.K2eig" href="#FlxQTL.flxMLMM.K2eig"><code>FlxQTL.flxMLMM.K2eig</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">   K2eig(K,LOCO::Bool=false)</code></pre><p>Returns eigenvectors and eigenvalues of a (genetic, climatic) relatedness, or 3-d array of these of a genetic relatedness if <code>LOCO</code> is <code>true</code>.</p><p><strong>Arguments</strong></p><ul><li><code>K</code> : A matrix of (genetic or climatic) relatedness (Default).  3-d array of genetic relatedness (<code>LOCO</code> sets to be true.)</li><li><code>LOCO</code> : Boolean. Default is <code>false</code> (no LOCO). (Leave One Chromosome Out).</li></ul><p><strong>Output</strong></p><ul><li><code>T</code> : A matrix of eigenvectors, or 3-d array of eigenvectors if <code>LOCO</code> sets to be <code>true</code>.</li><li><code>λ</code> : A vector of eigenvalues, or matrix of eigenvalues if <code>LOCO</code> sets to be <code>true</code>.</li></ul><p>See also <a href="#FlxQTL.flxMLMM.K2Eig"><code>K2Eig</code></a>.</p><p><strong>Examples</strong></p><p>For a (climatic) relatedness, or genetic relatedness for <code>LOCO =false</code>,</p><pre><code class="nohighlight hljs"> T, λ = K2eig(K)
</code></pre><p>produces a matrix of <code>T</code> and a vector of <code>λ</code>.</p><p>For a genetic kinship calculated under <code>LOCO</code> (3-d array of kinship),</p><pre><code class="nohighlight hljs"> T, λ = K2eig(K,true)
</code></pre><p>produces a 3-d array of <code>T</code> and a matrix of <code>λ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/FlxQTL.jl/blob/e4cde72221f550a5f6fd55e03b603b53ed2096a7/src/transformation.jl#L17-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FlxQTL.flxMLMM.gene2Scan" href="#FlxQTL.flxMLMM.gene2Scan"><code>FlxQTL.flxMLMM.gene2Scan</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gene2Scan(cross::Int64,Tg,Tc::Array{Float64,2},Λg,λc::Array{Float64,1},Y::Array{Float64,2},
         XX::Markers,Z::Array{Float64,2},LOCO::Bool=false;ρ=0.001,Xnul::Array{Float64,2}=ones(1,size(Y,2)), 
         df_prior=m+1,Prior::Matrix{Float64}=cov(Y,dims=2)*5,itol=1e-4,tol0=1e-3,tol::Float64=1e-4)
gene2Scan(cross::Int64,Tg,Λg,Y::Array{Float64,2},XX::Markers,Z::Array{Float64,2},LOCO::Bool=false;
           Xnul::Array{Float64,2}=ones(1,size(Y,2)),df_prior=m+1,Prior::Matrix{Float64}=cov(Y,dims=2)*5,
           itol=1e-3,tol0=1e-3,tol::Float64=1e-4,ρ=0.001)
gene2Scan(cross::Int64,Tg,Λg,Y::Array{Float64,2},XX::Markers,LOCO::Bool=false;Xnul::Array{Float64,2}=ones(1,size(Y,2)),
           df_prior=m+1,Prior::Matrix{Float64}=cov(Y,dims=2)*5,itol=1e-4,tol0=1e-3,tol::Float64=1e-4,ρ=0.001)</code></pre><p>Implement 2d-genome scan with/without LOCO (Leave One Chromosome Out). Note that the second <code>gene2Scan</code> includes <a href="#FlxQTL.flxMLMM.getKc-Tuple{Matrix{Float64}}"><code>getKc</code></a> for      precomputing <code>Kc</code>– no need of precomputing and doing eigen-decomposition to <code>Kc</code> separately.  The last <code>gene2Scan</code> is run by a conventional MLMM (no Z, i.e. Z=I):</p><p class="math-container">\[vec(Y) \sim MVN((Z \otimes X)vec(B) (or XBZ&#39;) , K \otimes \Sigma_1 +I \otimes \Sigma_2),\]</p><p>where <code>K</code> is a genetic kinship, <span>$\Sigma_1, \Sigma_2$</span> are covariance matrices for random and error terms, respectively.  <code>Z</code> can be replaced with an identity matrix.</p><p><strong>Arguments</strong></p><ul><li><code>cross</code> : An integer indicating the number of alleles or genotypes. Ex. 2 for RIF, 4 for four-way cross, 8 for HS mouse (allele probabilities), etc.         This value is related to degree of freedom when doing genome scan.</li><li><code>Tg</code> : A n x n matrix of eigenvectors from <a href="#FlxQTL.flxMLMM.K2eig"><code>K2eig</code></a>, or <a href="#FlxQTL.flxMLMM.K2Eig"><code>K2Eig</code></a>.      Returns 3d-array of eigenvectors as many as Chromosomes if <code>LOCO</code> is true.</li><li><code>Tc</code> : A m x m matrix of eigenvectors from the precomputed covariance matrix of <code>Kc</code> under the null model of no QTL.</li><li><code>Λg</code> : A n x 1 vector of eigenvalues from kinship. Returns a matrix of eigenvalues if <code>LOCO</code> is true.</li><li><code>λc</code> : A m x 1 vector of eigenvalues from <code>Kc</code>. </li><li><code>Y</code> : A m x n matrix of response variables, i.e. m traits (or environments) by n individuals (or lines). For univariate phenotypes, use square brackets in arguement.       i.e. <code>Y0[1,:]</code> (a vector) -&gt; <code>Y[[1],:]</code> (a matrix) .</li><li><code>XX</code> : A type of <a href="#FlxQTL.Util.Markers"><code>Markers</code></a>.</li><li><code>Z</code> :  An optional m x q matrix of low-dimensional phenotypic covariates, i.e. contrasts, basis functions (fourier, wavelet, polynomials, B-splines, etc.).       To use the identity matrix just as the conventional MLMM, simply type <code>diagm(ones(m))</code>.</li><li><code>LOCO</code> : Boolean. Default is <code>false</code> (no LOCO). Runs genome scan using LOCO (Leave One Chromosome Out).</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>Xnul</code> :  A matrix of covariates. Default is intercepts (1&#39;s).  Unless adding covariates, just leave as it is.  See <a href="#FlxQTL.flxMLMM.geneScan"><code>geneScan</code></a>.</li><li><code>Prior</code>: A positive definite scale matrix, <span>$\Psi$</span>, of prior Inverse-Wishart distributon, i.e. <span>$\Sigma \sim W^{-1}_m (\Psi, \nu_0)$</span>.           A large scaled covariance matrix (a weakly informative prior) is default.</li><li><code>df_prior</code>: degrees of freedom, <span>$\nu_0$</span> for Inverse-Wishart distributon.  <code>m+1</code> (weakly informative) is default.</li><li><code>itol</code> :  A tolerance controlling ECM (Expectation Conditional Maximization) under H0: no QTL. Default is <code>1e-3</code>.</li><li><code>tol0</code> :  A tolerance controlling ECM under H1: existence of QTL. Default is <code>1e-3</code>.</li><li><code>tol</code> : A tolerance of controlling Nesterov Acceleration Gradient method under both H0 and H1. Default is <code>1e-4</code>.</li><li><code>ρ</code> : A tunning parameter controlling <span>$\tau^2$</span>. Default is <code>0.001</code>.</li></ul><p>!!! Note</p><ul><li>When some LOD scores return negative values, reduce tolerences for ECM to <code>tol0 = 1e-4</code>. It works in most cases. If not,   can reduce both <code>tol0</code> and <code>tol</code> to <code>1e-4</code> or further.  2D scan is usually computationally heavy and takes much time especially for     large data with high-dimensional traits, i.e. large <code>m</code> and <code>n</code>.  This will be worse when the conventional LMM  is chosen.</li></ul><p><strong>Output</strong></p><ul><li><code>LODs</code> : LOD scores. Can change to <span>$- \log_{10}{P}$</span> using <a href="#FlxQTL.Util.lod2logP-Tuple{Union{Vector{Any}, Vector{Float64}}, Int64}"><code>lod2logP</code></a>.</li><li><code>est0</code> : A type of <code>EcmNestrv.Approx</code> including parameter estimates under H0: no QTL.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/FlxQTL.jl/blob/e4cde72221f550a5f6fd55e03b603b53ed2096a7/src/PgeneScan2D.jl#L81-L141">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FlxQTL.flxMLMM.geneScan" href="#FlxQTL.flxMLMM.geneScan"><code>FlxQTL.flxMLMM.geneScan</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">geneScan(cross::Int64,Tg,Tc::Array{Float64,2},Λg,λc::Array{Float64,1},Y::Array{Float64,2},XX::Markers,Z::Array{Float64,2},
         LOCO::Bool=false;m=size(Y,1),tdata::Bool=false,LogP::Bool=false,Xnul::Array{Float64,2}=ones(1,size(Y,2)),df_prior=m+1,
            Prior::Matrix{Float64}=cov(Y,dims=2)*5,itol=1e-3,tol0=1e-3,tol::Float64=1e-4,ρ=0.001)
geneScan(cross::Int64,Tg::Union{Array{Float64,3},Array{Float64,2}},Tc::Array{Float64,2},Λg::Union{Array{Float64,2},Array{Float64,1}},
         λc::Array{Float64,1},Y::Array{Float64,2},XX::Markers,LOCO::Bool=false;m=size(Y,1),LogP::Bool=false,Xnul::Array{Float64,2}=ones(1,size(Y,2)),df_prior=m+1,
    Prior::Matrix{Float64}=cov(Y,dims=2)*5,itol=1e-3,tol0=1e-3,tol::Float64=1e-4,ρ=0.001)
geneScan(cross::Int64,Tg,Λg,Y::Array{Float64,2},XX::Markers,LOCO::Bool=false;m=size(Y,1),Xnul::Array{Float64,2}=ones(1,size(Y,2)),
            df_prior=m+1,Prior::Matrix{Float64}=cov(Y,dims=2)*5,tdata::Bool=false,LogP::Bool=false,
           itol=1e-3,tol0=1e-3,tol::Float64=1e-4,ρ=0.001)
gene1Scan(cross::Int64,Tg,Λg,Y::Array{Float64,2},XX::Markers,Z::Array{Float64,2},LOCO::Bool=false;m=size(Y,1),
           Xnul::Array{Float64,2}=ones(1,size(Y,2)),df_prior=m+1,Prior::Matrix{Float64}=cov(Y,dims=2)*5,
             tdata::Bool=false,LogP::Bool=false,itol=1e-3,tol0=1e-3,tol::Float64=1e-4,ρ=0.001)</code></pre><p>Implement 1d-genome scan with/without LOCO (Leave One Chromosome Out).  Note that <code>gene1Scan</code> includes <a href="#FlxQTL.flxMLMM.getKc-Tuple{Matrix{Float64}}"><code>getKc</code></a> for      precomputing <code>Kc</code>– no need of precomputing and doing eigen-decomposition to <code>Kc</code> separately.  The third <code>geneScan()</code> is based on a conventional MLMM:</p><p class="math-container">\[vec(Y) \sim MVN((Z \otimes X)vec(B) (or XBZ&#39;),  K \otimes \Sigma_1 +I \otimes \Sigma_2),\]</p><p>where <code>K</code> is a genetic kinship, <span>$\Sigma_1, \Sigma_2$</span> are covariance matrices for random and error terms, respectively.  <code>Z</code> can be replaced with an identity matrix.</p><p><strong>Arguments</strong></p><ul><li><code>cross</code> : An integer indicating the number of alleles or genotypes. Ex. 2 for RIF, 4 for four-way cross, 8 for HS mouse (allele probabilities), etc.         This value is related to degree of freedom when doing genome scan.</li><li><code>Tg</code> : A n x n matrix of eigenvectors from <a href="#FlxQTL.flxMLMM.K2eig"><code>K2eig</code></a>, or <a href="#FlxQTL.flxMLMM.K2Eig"><code>K2Eig</code></a>.      Returns 3d-array of eigenvectors as many as Chromosomes if <code>LOCO</code> is true.</li><li><code>Tc</code> : A m x m matrix of eigenvectors from the precomputed covariance matrix of <code>Kc</code> under the null model of no QTL.</li><li><code>Λg</code> : A n x 1 vector of eigenvalues from kinship. Returns a matrix of eigenvalues if <code>LOCO</code> is true.</li><li><code>λc</code> : A m x 1 vector of eigenvalues from the precomputed covariance matrix of <code>Kc</code>. </li><li><code>Y</code> : A m x n matrix of response variables, i.e. m traits (or environments) by n individuals (or lines). For univariate phenotypes, use square brackets in arguement.       i.e. <code>Y0[1,:]</code> (a vector) -&gt;<code>Y[[1],:]</code> (a matrix) .</li><li><code>XX</code> : A type of <a href="#FlxQTL.Util.Markers"><code>Markers</code></a>.</li><li><code>Z</code> :  An optional m x q matrix of low-dimensional phenotypic covariates, i.e. contrasts, basis functions (fourier, wavelet, polynomials, B-splines, etc.).     If nothing to insert in <code>Z</code>, just exclude it or insert an identity matrix, <code>Matrix(1.0I,m,m)</code>.  m traits x q phenotypic covariates.</li><li><code>LOCO</code> : Boolean. Default is <code>false</code> (no LOCO). Runs genome scan using LOCO (Leave One Chromosome Out).</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>Xnul</code> :  A matrix of covariates. Default is intercepts (1&#39;s): <code>Xnul= ones(1,size(Y,2))</code>.  Adding covariates (C) is <code>Xnul= vcat(ones(1,n),C)</code> where <code>size(C)=(c,n)</code> for <code>n = size(Y0,2)</code>.</li><li><code>Prior</code>: A positive definite scale matrix, <span>$\Psi$</span>, of prior Inverse-Wishart distributon, i.e. <span>$\Sigma \sim W^{-1}_m (\Psi, \nu_0)$</span>.            A large scaled covariance matrix (a weakly informative prior) is default.</li><li><code>df_prior</code>: degrees of freedom, <span>$\nu_0$</span> for Inverse-Wishart distributon.  <code>m+1</code> (weakly informative) is default.</li><li><code>itol</code> :  A tolerance controlling ECM (Expectation Conditional Maximization) under H0: no QTL. Default is <code>1e-3</code>.</li><li><code>tol0</code> :  A tolerance controlling ECM under H1: existence of QTL. Default is <code>1e-3</code>.</li><li><code>tol</code> : A tolerance of controlling Nesterov Acceleration Gradient method under both H0 and H1. Default is <code>1e-4</code>.</li><li><code>ρ</code> : A tunning parameter controlling <span>$\tau^2$</span>. Default is <code>0.001</code>.</li><li><code>LogP</code> : Boolean. Default is <code>false</code>.  Returns <span>$-\log_{10}{P}$</span> instead of LOD scores if <code>true</code>.</li></ul><p>!!! Note</p><ul><li>When some LOD scores return negative values, reduce tolerences for ECM to <code>tol0 = 1e-4</code>. It works in most cases. If not,   can reduce both <code>tol0</code> and <code>tol</code> to <code>1e-4</code> or further.</li></ul><p><strong>Output</strong></p><ul><li><code>LODs</code> (or <code>logP</code>) : LOD scores. Can change to <span>$- \log_{10}{P}$</span> in <a href="#FlxQTL.Util.lod2logP-Tuple{Union{Vector{Any}, Vector{Float64}}, Int64}"><code>lod2logP</code></a> if <code>LogP = true</code>.</li><li><code>B</code> : A 3-d array of <code>B</code> (fixed effects) matrices under H1: existence of QTL.  If covariates are added to <code>Xnul</code> : <code>Xnul= [ones(1,size(Y,2)); Covariates]</code>,       ex. For sex covariates in 4-way cross analysis, B[:,2,100], B[:,3:5,100] are effects for sex, the rest genotypes of the 100th QTL, respectively.</li><li><code>est0</code> : A type of <code>EcmNestrv.Approx</code> including parameter estimates under H0: no QTL.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/FlxQTL.jl/blob/e4cde72221f550a5f6fd55e03b603b53ed2096a7/src/PgeneScan1D.jl#L108-L173">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FlxQTL.flxMLMM.getKc-Tuple{Matrix{Float64}}" href="#FlxQTL.flxMLMM.getKc-Tuple{Matrix{Float64}}"><code>FlxQTL.flxMLMM.getKc</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getKc(Y::Array{Float64,2};m=size(Y,1),Z=diagm(ones(m)), df_prior=m+1,
       Prior::Matrix{Float64}=cov(Y,dims=2)*5,Xnul::Array{Float64,2}=ones(1,size(Y,2)),
       itol=1e-2,tol::Float64=1e-3,ρ=0.001)</code></pre><p>Pre-estimate <code>Kc</code> by regressing <code>Y</code> on <code>Xnul</code>, i.e. estimating environmental covariates under <code>H0: no QTL</code>.</p><p><strong>Argument</strong></p><ul><li><code>Y</code> : A m x n matrix of response variables, i.e. m traits (or environments) by n individuals (or lines). For univariate phenotypes, use square brackets in arguement.       i.e. <code>Y0[1,:]</code> (a vector) -&gt;<code>Y[[1],:]</code> (a matrix) .</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>Z</code> :  An optional m x q matrix of low-dimensional phenotypic covariates, i.e. contrasts, basis functions (fourier, wavelet, polynomials, B-splines, etc.).       An identity matrix, <span>$I_m$</span>, is default. </li><li><code>Xnul</code> :  A matrix of covariates. Default is intercepts (1&#39;s): <code>Xnul= ones(1,size(Y0))</code>.  Adding covariates (C) is <code>Xnul= vcat(ones(1,m),C)</code> where <code>size(C)=(c,m)</code> for <code>m = size(Y0,1)</code>.</li><li><code>Prior</code>: A positive definite scale matrix, <span>$\Psi$</span>, of prior Inverse-Wishart distributon, i.e. <span>$\Sigma \sim W^{-1}_m (\Psi, \nu_0)$</span>.            A large scaled covariance matrix (a weakly informative prior) is default.</li><li><code>df_prior</code>: degrees of freedom, <span>$\nu_0$</span> for Inverse-Wishart distributon.  <code>m+1</code> (weakly informative) is default.</li><li><code>itol</code> :  A tolerance controlling ECM (Expectation Conditional Maximization) under H0: no QTL. Default is <code>1e-3</code>.</li><li><code>tol</code> : A tolerance of controlling Nesterov Acceleration Gradient method under both H0 and H1. Default is <code>1e-4</code>.</li><li><code>ρ</code> : A tunning parameter controlling <span>$\tau^2$</span>. Default is <code>0.001</code>.</li></ul><p><strong>Output</strong></p><ul><li><code>InitKc</code> :  A type of struct of arrays, including pre-estimated <code>Kc</code>,<code>and null estimates of B</code>, <code>Σ</code>,<code>τ2</code>used as initial values inside     <code>gene1Scan</code>, one of <a href="#FlxQTL.flxMLMM.geneScan"><code>geneScan</code></a> functions, or <a href="#FlxQTL.flxMLMM.gene2Scan"><code>gene2Scan</code></a>.</li></ul><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; K0 = getKc(Y)  
julia&gt; K0.Kc  # for Kc
julia&gt; K0.B # for B under H0
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/FlxQTL.jl/blob/e4cde72221f550a5f6fd55e03b603b53ed2096a7/src/transformation.jl#L212-L252">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FlxQTL.flxMLMM.permTest-Tuple{Int64, Any, Any, Any, Any, Markers}" href="#FlxQTL.flxMLMM.permTest-Tuple{Int64, Any, Any, Any, Any, Markers}"><code>FlxQTL.flxMLMM.permTest</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">  permTest(nperm::Int64,cross,Kg,Kc,Y,XX::Markers;pval=[0.05 0.01],m=size(Y,1),Z=diagm(ones(m)),df_prior=m+1,
         Prior::Matrix{Float64}=cov(Y,dims=2)*5,Xnul=ones(1,size(Y,2)),itol=1e-4,tol0=1e-3,tol=1e-4,ρ=0.001)
  permTest(nperm::Int64,cross,Kg,Y,XX::Markers;pval=[0.05 0.01],df_prior=m+1,
             Prior::Matrix{Float64}=cov(Y,dims=2)*5,Xnul=ones(1,size(Y,2)),itol=1e-4,tol0=1e-3,tol=1e-4,ρ=0.001)</code></pre><p>Implement permutation test to get thresholds at the levels of type 1 error, <code>α</code>.  Note that the last <code>permTest()</code>  is for the conventional MLMM: </p><p class="math-container">\[vec(Y)\sim MVN((I \otimes X)vec(B) (or BX), K \otimes \Sigma_1 +I \otimes \Sigma_2),\]</p><p>where <code>K</code> is a genetic kinship, <span>$\Sigma_1, \Sigma_2$</span> are covariance matrices for random and error terms, respectively.</p><p><strong>Arguments</strong></p><ul><li><code>nperm</code> : An integer indicating the number of permutation to be implemented.</li><li><code>cross</code> : An integer indicating the number of alleles or genotypes. Ex. <code>2</code> for RIF, <code>4</code> for four-way cross, <code>8</code> for HS mouse (allele probabilities), etc.         This value is related to degree of freedom when doing genome scan.</li><li><code>Kg</code> : A n x n genetic kinship matrix. Should be symmetric positive definite.</li><li><code>Kc</code> : A m x m precomputed covariance matrix of <code>Kc</code> under the null model of no QTL. Should be symmetric positive definite.</li><li><code>Y</code> : A m x n matrix of response variables, i.e. m traits (or environments) by n individuals (or lines). For univariate phenotypes, use square brackets in arguement.       i.e. <code>Y[1,:]</code>  (a vector) -&gt; <code>Y[[1],:]</code>  (a matrix) .</li><li><code>XX</code> : A type of <a href="#FlxQTL.Util.Markers"><code>Markers</code></a>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>pval</code> : A vector of p-values to get their quantiles. Default is <code>[0.05  0.01]</code> (without comma).</li><li><code>Xnul</code> : A matrix of covariates. Default is intercepts (1&#39;s).  Unless plugging in particular covariates, just leave as it is.</li><li><code>Z</code> :  An optional m x q matrix of low-dimensional phenotypic covariates, i.e. contrasts, basis functions (fourier, wavelet, polynomials, B-splines, etc.).       Default is an identity matrix for the dimension of m traits x q phenotypic covariates.</li><li><code>Prior</code>: A positive definite scale matrix, <span>$\Psi$</span>, of prior Inverse-Wishart distributon, i.e. <span>$\Sigma \sim W^{-1}_m (\Psi, \nu_0)$</span>.            A large scaled covariance matrix (a weakly informative prior) is default.</li><li><code>df_prior</code>: degrees of freedom, <span>$\nu_0$</span> for Inverse-Wishart distributon.  <code>m+1</code> (weakly informative) is default.</li><li><code>itol</code> : A tolerance controlling ECM (Expectation Conditional Maximization) under H0: no QTL. Default is <code>1e-3</code>.</li><li><code>tol0</code> : A tolerance controlling ECM under H1: existence of QTL. Default is <code>1e-3</code>.</li><li><code>tol</code> : A tolerance of controlling Nesterov Acceleration Gradient method under both H0 and H1. Default is <code>1e-4</code>.</li><li><code>ρ</code> : A tunning parameter controlling <span>$\tau^2$</span>. Default is <code>0.001</code>.  </li></ul><p><strong>Output</strong></p><ul><li><code>maxLODs</code> : A nperm x 1 vector of maximal LOD scores by permutation. </li><li><code>H1par_perm</code> : A type of struct, <code>EcmNestrv.Approx(B,τ2,Σ,loglik)</code> including parameter estimates  or <code>EcmNestrv.Result(B,Vc,Σ,loglik)</code>                for a conventional MLMM under H0: no QTL by permutation. </li><li><code>cutoff</code> : A vector of thresholds corresponding to <code>pval</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/FlxQTL.jl/blob/e4cde72221f550a5f6fd55e03b603b53ed2096a7/src/PpermutationTest.jl#L202-L249">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FlxQTL.flxMLMM.permutationTest-Tuple{Int64, Any, Any, Any, Any, Markers}" href="#FlxQTL.flxMLMM.permutationTest-Tuple{Int64, Any, Any, Any, Any, Markers}"><code>FlxQTL.flxMLMM.permutationTest</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">  permutationTest(nperm::Int64,cross,Kg,Kc,Y,XX::Markers;pval=[0.05 0.01],m=size(Y,1),Z=diagm(ones(m)),df_prior=m+1,
      Prior::Matrix{Float64}=cov(Y,dims=2)*5,Xnul=ones(1,size(Y,2)),itol=1e-4,tol0=1e-3,tol=1e-4,ρ=0.001)
  permutationTest(nperm::Int64,cross,Kg,Y,XX::Markers;pval=[0.05 0.01],m=size(Y,1),df_prior=m+1,
             Prior::Matrix{Float64}=cov(Y,dims=2)*5,Xnul=ones(1,size(Y,2)),itol=1e-4,tol0=1e-3,tol=1e-4,ρ=0.001)</code></pre><p>Implement permutation test by geneScan with LOCO  to get thresholds at the levels of type 1 error, <code>α</code>.  Note that the last <code>permutationTest()</code>  is for the conventional MLMM: </p><p class="math-container">\[vec(Y)\sim MVN((I \otimes X)vec(B) (or BX), K \otimes \Sigma_1 +I \otimes \Sigma_2),\]</p><p>where <code>K</code> is a genetic kinship, <span>$\Sigma_1, \Sigma_2$</span> are covariance matrices for random and error terms, respectively.</p><p>!!! NOTE</p><ul><li><code>permTest()</code> is implemented by geneScan without LOCO.  </li></ul><p><strong>Arguments</strong></p><ul><li><code>nperm</code> : An integer indicating the number of permutation to be implemented.</li><li><code>cross</code> : An integer indicating the number of alleles or genotypes. Ex. <code>2</code> for RIF, <code>4</code> for four-way cross, <code>8</code> for HS mouse (allele probabilities), etc.         This value is related to degree of freedom when doing genome scan.</li><li><code>Kg</code> : A n x n genetic kinship matrix. Should be symmetric positive definite.</li><li><code>Kc</code> : A m x m precomputed covariance matrix of <code>Kc</code> under the null model of no QTL. Should be symmetric positive definite.</li><li><code>Y</code> : A m x n matrix of response variables, i.e. m traits (or environments) by n individuals (or lines). For univariate phenotypes, use square brackets in arguement.       i.e. <code>Y[1,:]</code>  (a vector) -&gt; <code>Y[[1],:]</code>  (a matrix) .</li><li><code>XX</code> : A type of <a href="#FlxQTL.Util.Markers"><code>Markers</code></a>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>pval</code> : A vector of p-values to get their quantiles. Default is <code>[0.05  0.01]</code> (without comma).</li><li><code>Xnul</code> : A matrix of covariates. Default is intercepts (1&#39;s).  Unless plugging in particular covariates, just leave as it is.</li><li><code>Z</code> :  An optional m x q matrix of low-dimensional phenotypic covariates, i.e. contrasts, basis functions (fourier, wavelet, polynomials, B-splines, etc.).       Default is an identity matrix for the dimension of m traits x q phenotypic covariates.</li><li><code>Prior</code>: A positive definite scale matrix, <span>$\Psi$</span>, of prior Inverse-Wishart distributon, i.e. <span>$\Sigma \sim W^{-1}_m (\Psi, \nu_0)$</span>.            A large scaled covariance matrix (a weakly informative prior) is default.</li><li><code>df_prior</code>: degrees of freedom, <span>$\nu_0$</span> for Inverse-Wishart distributon.  <code>m+1</code> (weakly informative) is default.</li><li><code>itol</code> : A tolerance controlling ECM (Expectation Conditional Maximization) under H0: no QTL. Default is <code>1e-3</code>.</li><li><code>tol0</code> : A tolerance controlling ECM under H1: existence of QTL. Default is <code>1e-3</code>.</li><li><code>tol</code> : A tolerance of controlling Nesterov Acceleration Gradient method under both H0 and H1. Default is <code>1e-4</code>.</li><li><code>ρ</code> : A tunning parameter controlling <span>$\tau^2$</span>. Default is <code>0.001</code>.  </li></ul><p><strong>Output</strong></p><ul><li><code>maxLODs</code> : A nperm x 1 vector of maximal LOD scores by permutation. </li><li><code>H1par_perm</code> : A vector of structs, <code>EcmNestrv.Approx(B,τ2,Σ,loglik)</code> including parameter estimates  or <code>EcmNestrv.Result(B,Vc,Σ,loglik)</code>                for a conventional MLMM under H0: no QTL by permutation. </li><li><code>cutoff</code> : A vector of thresholds corresponding to <code>pval</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/FlxQTL.jl/blob/e4cde72221f550a5f6fd55e03b603b53ed2096a7/src/PpermutationTest1.jl#L216-L266">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FlxQTL.EcmNestrv" href="#FlxQTL.EcmNestrv"><code>FlxQTL.EcmNestrv</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">EcmNestrv</code></pre><p>A module for base algorithms using the ECM (Expectation-Conditional Maxization) with the Speed restarting Nesterov&#39;s accelerated gradient method  to fit a flexible multivariate linear mixed model (flxMLMM).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/FlxQTL.jl/blob/e4cde72221f550a5f6fd55e03b603b53ed2096a7/src/EcmNestrv.jl#L1-L8">source</a></section></article><h2 id="Genetic-Relatedness-Matrices-(GRM)"><a class="docs-heading-anchor" href="#Genetic-Relatedness-Matrices-(GRM)">Genetic Relatedness Matrices (GRM)</a><a id="Genetic-Relatedness-Matrices-(GRM)-1"></a><a class="docs-heading-anchor-permalink" href="#Genetic-Relatedness-Matrices-(GRM)" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FlxQTL.GRM" href="#FlxQTL.GRM"><code>FlxQTL.GRM</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> GRM</code></pre><p>A module for computing Genetic Relatedness Matrix (or kinship).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/FlxQTL.jl/blob/e4cde72221f550a5f6fd55e03b603b53ed2096a7/src/GRM.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FlxQTL.GRM.kinship4way-Tuple{Matrix{Float64}}" href="#FlxQTL.GRM.kinship4way-Tuple{Matrix{Float64}}"><code>FlxQTL.GRM.kinship4way</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> kinship4way(genmat::Array{Float64,2})</code></pre><p>Computes a kinship for four-way cross data counting different alleles between two markers: ex. AB-AB=0; AB-AC=1; AB-CD=2,<span>$\dots$</span> Note: In <a href="https://cran.r-project.org/web/packages/qtl/qtl.pdf">R/qtl</a>, genotypes are labeled as 1=AC; 2=BC; 3=AD; 4=BD by the function, <code>read.cross</code>.</p><p><strong>Argument</strong></p><ul><li><code>genmat</code> : A matrix of genotypes for <code>four-way cross</code> <span>$(1,2, \dots)$</span>.          size(genematrix)= (p,n), for <code>p</code> genetic markers x <code>n</code> individuals(or lines).</li></ul><p><strong>Output</strong></p><p>Returns a n x n symmetric matrix containing 1&#39;s on the diagonal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/FlxQTL.jl/blob/e4cde72221f550a5f6fd55e03b603b53ed2096a7/src/GRM.jl#L63-L80">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FlxQTL.GRM.kinshipCtr-Tuple{Matrix{Float64}}" href="#FlxQTL.GRM.kinshipCtr-Tuple{Matrix{Float64}}"><code>FlxQTL.GRM.kinshipCtr</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> kinshipCtr(genmat::Array{Float64,2})</code></pre><p>Calculates a kinship by a centered genotype matrix (linear kernel), i.e. genotypes subtracted by marker mean.</p><p><strong>Argument</strong></p><ul><li><code>genmat</code> : A matrix of genotype data (0,1,2). size(genmat)=(p,n) for <code>p</code> markers x <code>n</code> individuals</li></ul><p><strong>Output</strong></p><p>Returns a n x n symmetric matrix. See also <a href="#FlxQTL.GRM.kinshipStd-Tuple{Matrix{Float64}}"><code>kinshipStd</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/FlxQTL.jl/blob/e4cde72221f550a5f6fd55e03b603b53ed2096a7/src/GRM.jl#L172-L187">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FlxQTL.GRM.kinshipLin-Tuple{Any, Any}" href="#FlxQTL.GRM.kinshipLin-Tuple{Any, Any}"><code>FlxQTL.GRM.kinshipLin</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">kinshipLin(mat,cross)</code></pre><p>Calculates a kinship matrix by linear kernel.</p><p><strong>Arguments</strong></p><ul><li><code>mat</code> : A matrix of genotype (or allele) probabilities usually extracted from <a href="https://rqtl.org/tutorials/rqtltour.pdf">R/qtl</a>,       <a href="https://kbroman.org/qtl2/assets/vignettes/user_guide.html">R/qtl2</a>, or the counterpart packages. size(mat)= (p,n) for p genetic markers x n individuals.</li><li><code>cross</code> : A scalar indicating instances of alleles or genotypes in a genetic marker. ex. 1 for genotypes (labeled as 0,1,2), 2 for RIF, 4 for four-way cross, 8 for HS mouse (allele probabilities), etc.</li></ul><p><strong>Output</strong></p><p>Returns a n x n symmetric (positive definite) matrix containing 1&#39;s on the diagonal.</p><p>See also <a href="#FlxQTL.GRM.kinshipCtr-Tuple{Matrix{Float64}}"><code>kinshipCtr</code></a>, <a href="#FlxQTL.GRM.kinshipStd-Tuple{Matrix{Float64}}"><code>kinshipStd</code></a> for genetype data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/FlxQTL.jl/blob/e4cde72221f550a5f6fd55e03b603b53ed2096a7/src/GRM.jl#L141-L160">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FlxQTL.GRM.kinshipLoco" href="#FlxQTL.GRM.kinshipLoco"><code>FlxQTL.GRM.kinshipLoco</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> kinshipLoco(kin,g::Markers,cross::Int64=1)</code></pre><p>Generates a 3-d array of symmetric positive definite kinship matrices using LOCO (Leave One Chromosome Out) witout shrinkage intensity estimation. When a kinship is not positive definite, a tweak like a weighted average of kinship and Identity is used to correct minuscule negative eigenvalues.</p><p><strong>Arguments</strong></p><ul><li><code>kin</code> :  A function of computing a kinship. Can only use with <a href="#FlxQTL.GRM.kinshipCtr-Tuple{Matrix{Float64}}"><code>kinshipCtr</code></a>, <a href="#FlxQTL.GRM.kinshipStd-Tuple{Matrix{Float64}}"><code>kinshipStd</code></a> for genotypes, and with <a href="#FlxQTL.GRM.kinshipLin-Tuple{Any, Any}"><code>kinshipLin</code></a>         for genotype (or allele) probabilities.</li><li><code>g</code>   : A struct of arrays, type  <a href="#FlxQTL.Util.Markers"><code>Markers</code></a>.</li><li><code>cross</code> :  A scalar indicating instances of alleles or genotypes in a genetic marker.            ex. 1 for genotypes (0,1,2) as default, 2 for RIF, 4 for four-way cross, 8 for HS mouse (allele probabilities), etc.</li></ul><p><strong>Output</strong></p><p>Returns 3-d array of n x n symmetric positive definite matrices as many as Chromosomes. Refer to <a href="#FlxQTL.GRM.shrinkgLoco-Tuple{Any, Int64, Markers}"><code>shrinkgLoco</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/FlxQTL.jl/blob/e4cde72221f550a5f6fd55e03b603b53ed2096a7/src/GRM.jl#L358-L378">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FlxQTL.GRM.kinshipMan-Tuple{Matrix{Float64}}" href="#FlxQTL.GRM.kinshipMan-Tuple{Matrix{Float64}}"><code>FlxQTL.GRM.kinshipMan</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">  kinshipMan(genematrix::Array{Float64,2})</code></pre><p>Calculates a kinship matrix using a manhattan distance. Missing values need to be either omitted or imputed. This function is for recombinant inbred line (RIL) (AA/BB), not for 4-way cross genotype data.  See <a href="#FlxQTL.GRM.kinship4way-Tuple{Matrix{Float64}}"><code>kinship4way</code></a>.</p><p><strong>Argument</strong></p><ul><li><code>genematrix</code> : A matrix of genotypes, i.e. 0,1 (or 1,2).  size(genematrix)= (p,n) for <code>p</code> genetic markers x <code>n</code> individuals(or lines).</li></ul><p><strong>Output</strong></p><p>Returns a n x n symmetric matrix containing 1&#39;s on the diagonal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/FlxQTL.jl/blob/e4cde72221f550a5f6fd55e03b603b53ed2096a7/src/GRM.jl#L23-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FlxQTL.GRM.kinshipStd-Tuple{Matrix{Float64}}" href="#FlxQTL.GRM.kinshipStd-Tuple{Matrix{Float64}}"><code>FlxQTL.GRM.kinshipStd</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> kinshipStd(genmat::Array{Float64,2})</code></pre><p>Calculates a kinship by a standardized (or normalized) genotype matrix (linear kernel), i.e. genotypes subtracted by marker mean and divided by marker standard deviation.</p><p><strong>Argument</strong></p><ul><li><code>genmat</code> : A matrix of genotype data (0,1,2). size(genmat)=(p,n) for <code>p</code> markers x <code>n</code> individuals</li></ul><p><strong>Output</strong></p><p>Returns a n x n symmetric matrix. See also <a href="#FlxQTL.GRM.kinshipCtr-Tuple{Matrix{Float64}}"><code>kinshipCtr</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/FlxQTL.jl/blob/e4cde72221f550a5f6fd55e03b603b53ed2096a7/src/GRM.jl#L199-L216">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FlxQTL.GRM.shrinkg-Tuple{Any, Int64, Any}" href="#FlxQTL.GRM.shrinkg-Tuple{Any, Int64, Any}"><code>FlxQTL.GRM.shrinkg</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> shrinkg(f,nb::Int64,geno)</code></pre><p>Estimates a full-rank positive definite kinship matrix by shrinkage intensity estimation (bootstrap).  Can only use with <a href="#FlxQTL.GRM.kinshipMan-Tuple{Matrix{Float64}}"><code>kinshipMan</code></a>, <a href="#FlxQTL.GRM.kinship4way-Tuple{Matrix{Float64}}"><code>kinship4way</code></a>. This function runs faster by CPU parallelization.  Add workers/processes using <code>addprocs()</code> function before running for speedup.</p><p><strong>Arguments</strong></p><ul><li><code>f</code>: A function of computing a kinship. Can only use with <a href="#FlxQTL.GRM.kinshipMan-Tuple{Matrix{Float64}}"><code>kinshipMan</code></a>, <a href="#FlxQTL.GRM.kinship4way-Tuple{Matrix{Float64}}"><code>kinship4way</code></a>.</li><li><code>nb</code> : An integer indicating the number of bootstrap. It does not have to be a large number.</li><li><code>geno</code> : A matrix of genotypes. See <a href="#FlxQTL.GRM.kinshipMan-Tuple{Matrix{Float64}}"><code>kinshipMan</code></a>, <a href="#FlxQTL.GRM.kinship4way-Tuple{Matrix{Float64}}"><code>kinship4way</code></a> for dimension.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; using FlxQTL
julia&gt; addprocs(8)
julia&gt; K = shinkage(kinshipMan,20,myGeno)</code></pre><p><strong>Output</strong></p><p>Returns a full-rank symmetric positive definite matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/FlxQTL.jl/blob/e4cde72221f550a5f6fd55e03b603b53ed2096a7/src/GRM.jl#L229-L254">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FlxQTL.GRM.shrinkgLoco-Tuple{Any, Int64, Markers}" href="#FlxQTL.GRM.shrinkgLoco-Tuple{Any, Int64, Markers}"><code>FlxQTL.GRM.shrinkgLoco</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">   shrinkgLoco(kin,nb,g::Markers)</code></pre><p>Generates 3-d array of full-rank positive definite kinship matrices by shrinkage intensity estimation (bootstrap) using a LOCO (Leave One Chromosome Out) scheme.</p><p><strong>Argument</strong></p><ul><li><code>kin</code> :  A function of computing a kinship. Can only use with <a href="#FlxQTL.GRM.kinshipMan-Tuple{Matrix{Float64}}"><code>kinshipMan</code></a>, <a href="#FlxQTL.GRM.kinship4way-Tuple{Matrix{Float64}}"><code>kinship4way</code></a></li><li><code>nb</code> : An integer indicating the number of bootstrap.</li><li><code>g</code> : A struct of arrays, type <a href="#FlxQTL.Util.Markers"><code>Markers</code></a>.</li></ul><p><strong>Output</strong></p><p>Returns 3-d array of n x n symmetric positive definite matrices as many as Chromosomes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/FlxQTL.jl/blob/e4cde72221f550a5f6fd55e03b603b53ed2096a7/src/GRM.jl#L316-L335">source</a></section></article><h2 id="Flexible-Multivariate-Linear-Models-(flxMLM)"><a class="docs-heading-anchor" href="#Flexible-Multivariate-Linear-Models-(flxMLM)">Flexible Multivariate Linear Models (flxMLM)</a><a id="Flexible-Multivariate-Linear-Models-(flxMLM)-1"></a><a class="docs-heading-anchor-permalink" href="#Flexible-Multivariate-Linear-Models-(flxMLM)" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FlxQTL.flxMLM" href="#FlxQTL.flxMLM"><code>FlxQTL.flxMLM</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">flxMLM</code></pre><p>A module designed for fitting a Multivariate Linear Model by the (Residual) Maximum Likelihood (REML or MLE) method.   The model:</p><p><span>$Y=XBZ&#39;+E$</span>, where <span>$E(vec(Y))= (Z \otimes X)vec(B)$</span>,  <span>$var(vec(Y))=  I_n \otimes \Sigma$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/FlxQTL.jl/blob/e4cde72221f550a5f6fd55e03b603b53ed2096a7/src/flxMLM.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FlxQTL.flxMLM.mlm1Scan" href="#FlxQTL.flxMLM.mlm1Scan"><code>FlxQTL.flxMLM.mlm1Scan</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mlm1Scan(cross::Int64,Y::Matrix{Float64},XX::Markers,Z::Matrix{Float64},reml::Bool=false;LogP::Bool=false,
          Xnul::Matrix{Float64}=ones(size(Y,1),1))
mlm1Scan(cross::Int64,Y::Matrix{Float64},XX::Markers,reml::Bool=false;LogP::Bool=false,
          Xnul::Matrix{Float64}=ones(size(Y,1),1))</code></pre><p>Implement 1d-genome scan.  The second <code>mlm1Scan()</code> is for <code>Z=I</code> case;  one can also run the first by inserting an identity matrix (I) into <code>Z</code>. <code>math  vec(Y) \sim MVN (  (Z \otimes X)vec(B) (or XBZ&#39;), \Sigma \otimes I),</code> where size(Y)=(n,m), size(X)=(n,p), size(Z)=(m,q).</p><p><strong>Arguments</strong></p><ul><li><code>cross</code> : An integer indicating the number of alleles or genotypes. Ex. 2 for RIF, 4 for four-way cross, 8 for HS mouse (allele probabilities), etc.         This value is related to degree of freedom when doing genome scan.</li><li><code>Y</code> : A n x m matrix of response variables, i.e. n individuals (or lines) by m traits (or environments). For univariate phenotypes, use square brackets in arguement.       i.e. <code>Y0[:,1]</code> (a vector) -&gt;<code>Y[:,[1]]</code> (a matrix) .</li><li><code>XX</code> : A type of <a href="#FlxQTL.Util.Markers"><code>Markers</code></a>. Be cautious when combining genotype infomation into the struct of <code>Markers</code>; <code>size(X) = (n,p)</code>.</li><li><code>Z</code> :  An optional m x q matrix of low-dimensional phenotypic covariates, i.e. contrasts, basis functions (fourier, wavelet, polynomials, B-splines, etc.).     If nothing to insert in <code>Z</code>, just exclude it or insert an identity matrix, <code>Matrix(1.0I,m,m)</code>.  m traits x q phenotypic covariates.</li><li><code>reml</code>: Boolean.  Default is fitting the model via mle. Resitricted MLE is implemented if <code>true</code>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>Xnul</code> :  A matrix of covariates. Default is intercepts (1&#39;s): <code>Xnul= ones(size(Y,1),1)</code>.  Adding covariates (C) is <code>Xnul= hcat(ones(n),C)</code> where <code>size(C)=(c,n)</code> for <code>n = size(Y,1)</code>.</li><li><code>LogP</code> : Boolean. Default is <code>false</code>.  Returns <span>$-\log_{10}{P}$</span> instead of LOD scores if <code>true</code>.</li></ul><p><strong>Output</strong></p><ul><li><code>LODs</code> (or <code>logP</code>) : LOD scores. Can change to <span>$- \log_{10}{P}$</span> in <a href="#FlxQTL.Util.lod2logP-Tuple{Union{Vector{Any}, Vector{Float64}}, Int64}"><code>lod2logP</code></a> if <code>LogP = true</code>.</li><li><code>B</code> : A 3-d array of <code>B</code> (fixed effects) matrices under H1: existence of QTL.  If covariates are added to <code>Xnul</code> : <code>Xnul= [ones(size(Y,1)) Covariates]</code>,       ex. For sex covariates in 4-way cross analysis, B[2,:,100], B[3:5,:,100] are effects for sex, the rest genotypes of the 100th QTL, respectively.</li><li><code>est0</code> : A type of <code>MLM.Estimat</code> including parameter estimates under H0: no QTL.              </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/FlxQTL.jl/blob/e4cde72221f550a5f6fd55e03b603b53ed2096a7/src/geneScan.jl#L112-L149">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FlxQTL.flxMLM.mlm2Scan" href="#FlxQTL.flxMLM.mlm2Scan"><code>FlxQTL.flxMLM.mlm2Scan</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> mlm2Scan(cross::Int64,Y::Matrix{Float64},XX::Markers,Z::Matrix{Float64},reml::Bool=false;Xnul::Matrix{Float64}=ones(size(Y,1),1))
 mlm2Scan(cross::Int64,Y::Matrix{Float64},XX::Markers,reml::Bool=false;Xnul::Matrix{Float64}=ones(size(Y,1),1))</code></pre><p>Implement 2d-genome scan.  The second <code>mlm2Scan()</code> is for <code>Z=I</code> case;  one can also run the first by inserting an identity matrix (I) into <code>Z</code>. <code>math  vec(Y) \sim MVN (  (Z \otimes X)vec(B) (or XBZ&#39;), \Sigma \otimes I),</code> where size(Y)=(n,m), size(X)=(n,p), size(Z)=(m,q).</p><p><strong>Arguments</strong></p><ul><li><code>cross</code> : An integer indicating the number of alleles or genotypes. Ex. 2 for RIF, 4 for four-way cross, 8 for HS mouse (allele probabilities), etc.         This value is related to degree of freedom when doing genome scan.</li><li><code>Y</code> : A n x m matrix of response variables, i.e. n individuals (or lines) by m traits (or environments). For univariate phenotypes, use square brackets in arguement.       i.e. <code>Y0[:,1]</code> (a vector) -&gt;<code>Y[:,[1]]</code> (a matrix) .</li><li><code>XX</code> : A type of <a href="#FlxQTL.Util.Markers"><code>Markers</code></a>.  Be cautious when combining genotype infomation into the struct of <code>Markers</code>; <code>size(X) = (n,p)</code>.</li><li><code>Z</code> :  An optional m x q matrix of low-dimensional phenotypic covariates, i.e. contrasts, basis functions (fourier, wavelet, polynomials, B-splines, etc.).     If nothing to insert in <code>Z</code>, just exclude it or insert an identity matrix, <code>Matrix(1.0I,m,m)</code>.  m traits x q phenotypic covariates.</li><li><code>reml</code>: Boolean.  Default is fitting the model via mle. Resitricted MLE is implemented if <code>true</code>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>Xnul</code> :  A matrix of covariates. Default is intercepts (1&#39;s).  Unless adding covariates, just leave as it is.  See <a href="#FlxQTL.flxMLM.mlm1Scan"><code>mlm1Scan</code></a>.</li></ul><p><strong>Output</strong></p><ul><li><code>LODs</code> : LOD scores. Can change to <span>$- \log_{10}{P}$</span> using <a href="#FlxQTL.Util.lod2logP-Tuple{Union{Vector{Any}, Vector{Float64}}, Int64}"><code>lod2logP</code></a>.</li><li><code>est0</code> : A type of <code>MLM.Estimat</code> including parameter estimates under H0: no QTL.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/FlxQTL.jl/blob/e4cde72221f550a5f6fd55e03b603b53ed2096a7/src/geneScan.jl#L211-L244">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FlxQTL.flxMLM.mlmTest" href="#FlxQTL.flxMLM.mlmTest"><code>FlxQTL.flxMLM.mlmTest</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> mlmTest(nperm::Int64,cross::Int64,Y::Matrix{Float64},XX::Markers,Z::Matrix{Float64},reml::Bool=false;
          Xnul::Matrix{Float64}=ones(size(Y,1),1),pval=[0.05 0.01])
 mlmTest(nperm::Int64,cross::Int64,Y::Matrix{Float64},XX::Markers,reml::Bool=false;
          Xnul::Matrix{Float64}=ones(size(Y,1),1),pval=[0.05 0.01])</code></pre><p>Implement permutation test to get thresholds at the levels of type 1 error, <code>α</code>.  The second <code>mlmTest()</code> is for <code>Z=I</code> case;  one can also run the first by inserting an identity matrix (I) into <code>Z</code>. <code>math  vec(Y) \sim MVN (  (Z \otimes X)vec(B) (or XBZ&#39;), \Sigma \otimes I),</code> where size(Y)=(n,m), size(X)=(n,p), size(Z)=(m,q).</p><p><strong>Arguments</strong></p><ul><li><code>nperm</code> : An integer indicating the number of permutation to be implemented.</li><li><code>cross</code> : An integer indicating the number of alleles or genotypes. Ex. <code>2</code> for RIF, <code>4</code> for four-way cross, <code>8</code> for HS mouse (allele probabilities), etc.         This value is related to degree of freedom when doing genome scan.</li><li><code>Y</code> : A n x m matrix of response variables, i.e. n individuals (or lines) by m traits (or environments). For univariate phenotypes, use square brackets in arguement.       i.e. <code>Y[:,1]</code>  (a vector) -&gt; <code>Y[:,[1]]</code>  (a matrix) .</li><li><code>XX</code> : A type of <a href="#FlxQTL.Util.Markers"><code>Markers</code></a>.  Be cautious when combining genotype infomation into the struct of <code>Markers</code>; <code>size(X) = (n,p)</code>.</li><li><code>reml</code>: Boolean.  Default is fitting the model via mle. Resitricted MLE is implemented if <code>true</code>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>pval</code> : A vector of p-values to get their quantiles. Default is <code>[0.05  0.01]</code> (without comma).</li><li><code>Xnul</code> : A matrix of covariates. Default is intercepts (1&#39;s).  Unless plugging in particular covariates, just leave as it is.</li><li><code>Z</code> :  An optional m x q matrix of low-dimensional phenotypic covariates, i.e. contrasts, basis functions (fourier, wavelet, polynomials, B-splines, etc.).       Default is an identity matrix for the dimension of m traits x q phenotypic covariates.</li></ul><p><strong>Output</strong></p><ul><li><p><code>maxLODs</code> : A nperm x 1 vector of maximal LOD scores by permutation. </p></li><li><p><code>H1par_perm</code> : A type of struct, <code>MLM.Estimat(B,Σ,loglik)</code> including parameter estimates                 for a MLM under H0: no QTL by permutation. </p></li><li><p><code>cutoff</code> : A vector of thresholds corresponding to <code>pval</code>.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/FlxQTL.jl/blob/e4cde72221f550a5f6fd55e03b603b53ed2096a7/src/geneScan.jl#L302-L344">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FlxQTL.MLM" href="#FlxQTL.MLM"><code>FlxQTL.MLM</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">  MLM</code></pre><p>A module for fitting general Multivariate Linear Models motivated by functional data analysis via mle or reml. The default fitting method is mle. ( i.e. reml=false)</p><p>The model:  <span>$Y=XBZ&#39;+E$</span>, where <span>$E(Y)=XBZ&#39;$</span> (or <span>$E(vec(Y))= (Z \otimes X)vec(B)$</span> ),  <span>$var(vec(E))=\Sigma \otimes I.$</span> size(Y)=(n,m), size(X)=(n,p), size(Z)=(m,q).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/FlxQTL.jl/blob/e4cde72221f550a5f6fd55e03b603b53ed2096a7/src/MLM.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FlxQTL.MLM.Estimat" href="#FlxQTL.MLM.Estimat"><code>FlxQTL.MLM.Estimat</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> Estimat(B::Array{Float64,2},Σ::Array{Float64,2},loglik::Float64)</code></pre><p>A struct of arrays for results by fitting a multivariate linear model,  <code>mGLM()</code>.   The results are <code>B</code>(fixed effects), <code>Σ</code> (m x m covariance matrix), <code>loglik</code>(a value of log-likelihood by mle or reml).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/FlxQTL.jl/blob/e4cde72221f550a5f6fd55e03b603b53ed2096a7/src/MLM.jl#L217-L224">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FlxQTL.MLM.mGLM" href="#FlxQTL.MLM.mGLM"><code>FlxQTL.MLM.mGLM</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">  mGLM(Y::Array{Float64,2},X::Array{Float64,2},Z::Array{Float64,2},reml::Bool=false)
  mGLM(Y::Array{Float64,2},X::Array{Float64,2},reml::Bool=false)</code></pre><p>Fitting multivariate General Linear Models via MLE (or REML) and returns a type of a struct <code>Estimat</code>.  </p><p><strong>Arguments</strong></p><ul><li><code>Y</code> : A matrix of response variables, i.e. traits. size(Y)=(n,m) for n individuals x m traits</li><li><code>X</code> : A matrix of independent variables, i.e. genotypes or genotype probabilities including intercept or/and covariates. size(X)=(n,p) for n individuals x p markers      including intercept or/and covariates </li><li><code>Z</code> : An optional matrix of low-dimensional phenotypic covariates, i.e. contrasts, basis functions (fourier, wavelet, polynomials, B-splines, etc.).      If nothing to insert in <code>Z</code>, just exclude it or insert <code>Matrix(1.0I,m,m)</code>. size(Z)=(m,q) for m traits x q phenotypic covariates.</li><li><code>reml</code> : Boolean. Default is fitting the model via mle. Resitricted MLE is implemented if <code>true</code>. </li></ul><p><strong>Output</strong></p><p>Returns <a href="#FlxQTL.MLM.Estimat"><code>Estimat</code></a> .</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/FlxQTL.jl/blob/e4cde72221f550a5f6fd55e03b603b53ed2096a7/src/MLM.jl#L126-L148">source</a></section></article><h2 id="Utility-Functions-(Util)"><a class="docs-heading-anchor" href="#Utility-Functions-(Util)">Utility Functions (Util)</a><a id="Utility-Functions-(Util)-1"></a><a class="docs-heading-anchor-permalink" href="#Utility-Functions-(Util)" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FlxQTL.Util" href="#FlxQTL.Util"><code>FlxQTL.Util</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> Util</code></pre><p>A module for utility functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/FlxQTL.jl/blob/e4cde72221f550a5f6fd55e03b603b53ed2096a7/src/Miscellanea.jl#L2-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FlxQTL.Util.Markers" href="#FlxQTL.Util.Markers"><code>FlxQTL.Util.Markers</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Markers(name::Array{String,1},chr::Array{Any,1},pos::Array{Float64,1},X::Array{Float64,2})</code></pre><p>A struct of arrays creating genotype or genotype probability data for genome scan.</p><p><strong>Arguments</strong></p><ul><li><code>name</code> : A vector of marker names</li><li><code>chr</code>  : A vector of Chromosomes</li><li><code>pos</code>  : A vector of marker positions (cM)</li><li><code>X</code> : A matrix of genotypes or genotype probabilities</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/FlxQTL.jl/blob/e4cde72221f550a5f6fd55e03b603b53ed2096a7/src/Miscellanea.jl#L53-L66">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FlxQTL.Util.Y_huber-Tuple{Matrix{Float64}}" href="#FlxQTL.Util.Y_huber-Tuple{Matrix{Float64}}"><code>FlxQTL.Util.Y_huber</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Y_huber(Y::Array{Float64,2})</code></pre><p>Rescale Y (phenotype or trait data) to be less sensitive to outliers using by Huber loss function and MAD (median absolute deviation).  size(Y)=(m,n) for <code>m</code> trait and <code>n</code> individuals.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/FlxQTL.jl/blob/e4cde72221f550a5f6fd55e03b603b53ed2096a7/src/Miscellanea.jl#L350-L357">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FlxQTL.Util.array2mat-Tuple{Int64, Array{Float64, 3}}" href="#FlxQTL.Util.array2mat-Tuple{Int64, Array{Float64, 3}}"><code>FlxQTL.Util.array2mat</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> array2mat(cross::Int64,X0::Array{Float64,3})</code></pre><p>Returns a 3-d array to a matrix of genotype probabilities. size(X0)=(cross,n,p) –&gt; (p1,n), where <code>p1</code> = <code>cross*p</code> for <code>p</code> markers,  <code>cross</code> alleles or genotypes, and <code>n</code> individuals. See <a href="#FlxQTL.Util.mat2array-Tuple{Int64, Any}"><code>mat2array</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/FlxQTL.jl/blob/e4cde72221f550a5f6fd55e03b603b53ed2096a7/src/Miscellanea.jl#L141-L149">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FlxQTL.Util.getFinoidx-Tuple{Matrix{Union{Missing, Float64}}}" href="#FlxQTL.Util.getFinoidx-Tuple{Matrix{Union{Missing, Float64}}}"><code>FlxQTL.Util.getFinoidx</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getFinoidx(phenoData::Array{Union{Missing,Float64},2})</code></pre><p>Attains indices of phenotype data without missing values.</p><p><strong>Argument</strong></p><ul><li><code>phenoData</code> : A matrix of phenotype (or trait) data including missing values. size(phenoData) = (m,n) for <code>m</code> traits and <code>n</code> individuals.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/FlxQTL.jl/blob/e4cde72221f550a5f6fd55e03b603b53ed2096a7/src/Miscellanea.jl#L224-L234">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FlxQTL.Util.getGenoidx" href="#FlxQTL.Util.getGenoidx"><code>FlxQTL.Util.getGenoidx</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getGenoidx(GenoData::Union{Array{Any,2},Array{Float64,2}},maf::Float64=0.025)</code></pre><p>Attains genotype indices to drop correlated or bad markers.</p><p><strong>Arguments</strong></p><ul><li><code>GenoData</code> : A matrix of genotype data. size(GenoData)= (p,n) for <code>p</code> markers and <code>n</code> individuals.</li><li><code>maf</code> : A scalar for dropping criterion of markers. Default is <code>0.025</code> i.e. markers of MAF &lt; 0.025 are dropped.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/FlxQTL.jl/blob/e4cde72221f550a5f6fd55e03b603b53ed2096a7/src/Miscellanea.jl#L203-L213">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FlxQTL.Util.lod2logP-Tuple{Union{Vector{Any}, Vector{Float64}}, Int64}" href="#FlxQTL.Util.lod2logP-Tuple{Union{Vector{Any}, Vector{Float64}}, Int64}"><code>FlxQTL.Util.lod2logP</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lod2logP(LODs::Union{Array{Float64,1},Array{Any,1}},v::Int64)</code></pre><p>Caculates <span>$-\log_{10}{P}$</span> from LOD scores.</p><p><strong>Arguments</strong></p><ul><li><code>LODs</code> : A vector of LOD scores computed from genome scan.</li><li><code>v</code> : Degrees of freedom for Chi-squared distribution.  </li></ul><p>!!! NOTE</p><ul><li>To compute degrees of freedom for 1D-genome scan (<code>geneScan</code>), <code>v = prod(size(B1))-prod(size(B0)</code>, where <code>B1</code> and <code>B0</code> are effect size matrices under H1 of a full model (intercept + covariates + QTL) and H0 of no QTL (intercept + covariates), respectively.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/FlxQTL.jl/blob/e4cde72221f550a5f6fd55e03b603b53ed2096a7/src/Miscellanea.jl#L243-L256">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FlxQTL.Util.mat2array-Tuple{Int64, Any}" href="#FlxQTL.Util.mat2array-Tuple{Int64, Any}"><code>FlxQTL.Util.mat2array</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> mat2array(cross::Int64,X0)</code></pre><p>Returns a matrix of genotype probabilities to 3-d array. size(X0)=(p1,n) –&gt; (cross,n,p), where <code>p1</code> = <code>cross*p</code> for <code>p</code> markers,  <code>cross</code> alleles or genotypes, and <code>n</code> individuals.</p><p><strong>Argument</strong></p><ul><li><code>cross</code> : An integer indicating the number of alleles or genotypes. Ex. 2 for RIF, 4 for four-way cross, 8 for HS mouse (allele probabilities), etc.</li><li><code>X0</code> : A matrix of genotype probability data computed from r/qtl or r/qtl2.  </li></ul><p>See <a href="#FlxQTL.Util.array2mat-Tuple{Int64, Array{Float64, 3}}"><code>array2mat</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/FlxQTL.jl/blob/e4cde72221f550a5f6fd55e03b603b53ed2096a7/src/Miscellanea.jl#L116-L130">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FlxQTL.Util.mat2vec-Tuple{Any}" href="#FlxQTL.Util.mat2vec-Tuple{Any}"><code>FlxQTL.Util.mat2vec</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> mat2vec(mat)</code></pre><p>Stacks a matrix to a vector, i.e. vectorizing a matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/FlxQTL.jl/blob/e4cde72221f550a5f6fd55e03b603b53ed2096a7/src/Miscellanea.jl#L98-L104">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FlxQTL.Util.newMarkers" href="#FlxQTL.Util.newMarkers"><code>FlxQTL.Util.newMarkers</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">newMarkers(XX::Markers,cross::Int64,cM::Int64=2)</code></pre><p>Returns a struct of Markers by keeping only markers positioned in every <code>cM</code> centimorgans for 2-d genome scan to avoid singularity.</p><p><strong>Arguments</strong></p><ul><li><code>XX</code> : A type of <code>Markers</code>. See <a href="#FlxQTL.Util.Markers"><code>Markers</code></a>.</li><li><code>cross</code> : An integer indicating the number of alleles or genotypes. Ex. 2 for RIF, 4 for four-way cross, 8 for HS mouse (allele probabilities), etc.</li><li><code>cM</code> : An integer of dropping criterion of markers. Default is 2, i.e. keeping only markers in every 2 cM, or dropping markers within 2cM between 2 markers.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/FlxQTL.jl/blob/e4cde72221f550a5f6fd55e03b603b53ed2096a7/src/Miscellanea.jl#L311-L323">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FlxQTL.Util.ordrMarkers-Tuple{Matrix{Any}}" href="#FlxQTL.Util.ordrMarkers-Tuple{Matrix{Any}}"><code>FlxQTL.Util.ordrMarkers</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ordrMarkers(markers::Array{Any,2})</code></pre><p>Rearrange by CPU parallelization marker information composed of marker name, chr, position obtained from rqtl2, which is not listed in order (excluding <code>X</code> chromosome).</p><p><strong>Argument</strong></p><ul><li><code>markers</code> : An array of marker information.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/FlxQTL.jl/blob/e4cde72221f550a5f6fd55e03b603b53ed2096a7/src/Miscellanea.jl#L76-L86">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FlxQTL.Util.setSeed-Tuple{Int64}" href="#FlxQTL.Util.setSeed-Tuple{Int64}"><code>FlxQTL.Util.setSeed</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">setSeed(seedNum::Int64)</code></pre><p>Assigns different numbers of seeds to workers (or processes) for reproducibility.</p><p><strong>Arguments</strong></p><ul><li><code>seedNum</code>: An integer.  A minimum seed number to assign a worker.  For distributed computing, seed numbers are generated for multiple workers by increasing 1, e.g. seedNum = 123 &amp; 10 workers, <code>setSeed</code> generates seeds from 123 to 132 and assigns to corresponding workers (processes). </li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; using Distributed
julia&gt; addprocs(10)
julia&gt; @everywhere using flxQTL
julia&gt; setSeed(123)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/FlxQTL.jl/blob/e4cde72221f550a5f6fd55e03b603b53ed2096a7/src/Miscellanea.jl#L19-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FlxQTL.Util.sortBycM" href="#FlxQTL.Util.sortBycM"><code>FlxQTL.Util.sortBycM</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">    sortBycM(Chr::Any,XX::Markers,cross::Int64,cM::Int64=2)</code></pre><p>Returns marker indices in Chromosome <code>Chr</code> and the corresponding genotype probabilities keeping only markers positioned in every <code>cM</code> centimorgans  for 2-d genome scan to avoid singularity.</p><p><strong>Arguments</strong></p><ul><li><code>Chr</code> : A type of Any indicating a particular chromosome to sort markers out.</li><li><code>XX</code> : A type of <a href="#FlxQTL.Util.Markers"><code>Markers</code></a>.</li><li><code>cross</code> : An integer indicating the number of alleles or genotypes. Ex. 2 for RIF, 4 for four-way cross, 8 for HS mouse (allele probabilities), etc.</li><li><code>cM</code> : An integer of dropping criterion of markers. Default is 2, i.e. keeping only markers in every 2 cM, or dropping markers within 2cM between 2 markers.</li></ul><p>See also <a href="#FlxQTL.Util.newMarkers"><code>newMarkers</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/FlxQTL.jl/blob/e4cde72221f550a5f6fd55e03b603b53ed2096a7/src/Miscellanea.jl#L265-L281">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../guide/analysis/">« QTL Analysis</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.13.0 on <span class="colophon-date" title="Saturday 21 June 2025 19:48">Saturday 21 June 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
