<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Types and Functions · FlxQTL.jl</title><meta name="title" content="Types and Functions · FlxQTL.jl"/><meta property="og:title" content="Types and Functions · FlxQTL.jl"/><meta property="twitter:title" content="Types and Functions · FlxQTL.jl"/><meta name="description" content="Documentation for FlxQTL.jl."/><meta property="og:description" content="Documentation for FlxQTL.jl."/><meta property="twitter:description" content="Documentation for FlxQTL.jl."/><meta property="og:url" content="https://senresearch.github.io/FlxQTL.jl/stable/functions/"/><meta property="twitter:url" content="https://senresearch.github.io/FlxQTL.jl/stable/functions/"/><link rel="canonical" href="https://senresearch.github.io/FlxQTL.jl/stable/functions/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">FlxQTL.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../guide/tutorial/">Package Guide</a></li><li><a class="tocitem" href="../guide/analysis/">QTL Analysis</a></li><li class="is-active"><a class="tocitem" href>Types and Functions</a><ul class="internal"><li><a class="tocitem" href="#Flexible-Multivariate-Linear-Mixed-Models-(flxMLMM)"><span>Flexible Multivariate Linear Mixed Models (flxMLMM)</span></a></li><li><a class="tocitem" href="#Genetic-Relatedness-Matrices-(GRM)"><span>Genetic Relatedness Matrices (GRM)</span></a></li><li><a class="tocitem" href="#Flexible-Multivariate-Linear-Models-(flxMLM)"><span>Flexible Multivariate Linear Models (flxMLM)</span></a></li><li><a class="tocitem" href="#Utility-Functions-(Util)"><span>Utility Functions (Util)</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Types and Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Types and Functions</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/senresearch/FlxQTL.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/senresearch/FlxQTL.jl/blob/master/docs/src/functions.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Functions-and-Types"><a class="docs-heading-anchor" href="#Functions-and-Types">Functions and Types</a><a id="Functions-and-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Functions-and-Types" title="Permalink"></a></h1><h2 id="Flexible-Multivariate-Linear-Mixed-Models-(flxMLMM)"><a class="docs-heading-anchor" href="#Flexible-Multivariate-Linear-Mixed-Models-(flxMLMM)">Flexible Multivariate Linear Mixed Models (flxMLMM)</a><a id="Flexible-Multivariate-Linear-Mixed-Models-(flxMLMM)-1"></a><a class="docs-heading-anchor-permalink" href="#Flexible-Multivariate-Linear-Mixed-Models-(flxMLMM)" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FlxQTL.FlxQTL" href="#FlxQTL.FlxQTL"><code>FlxQTL.FlxQTL</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FlxQTL</code></pre><p>Flexible QTL analysis tools for structured multiple traits fitting a Multivariate Linear Mixed Model or a Multivariate      Linear Model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/FlxQTL.jl/blob/3f98e4000af8f88b3f5d817e824352aa3fbd0019/src/FlxQTL.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FlxQTL.flxMLMM" href="#FlxQTL.flxMLMM"><code>FlxQTL.flxMLMM</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">flxMLMM</code></pre><p>A module designed for fitting a Multivariate Linear Mixed Model run by the Nesterov&#39;s Accelerated Gradient with restarting scheme embedding the Expectation Conditional Maximization to  estimate MLEs.  REML is not supported.  The FlxQTL model is defined as </p><p class="math-container">\[vec(Y)\sim MVN((X&#39; \otimes Z)vec(B) (or ZBX), K \otimes \Omega +I \otimes \Sigma),\]</p><p>where <code>K</code> is a genetic kinship, and <span>$\Omega \approx \tau^2V_C$</span>, <span>$\Sigma$</span> are covariance matrices for random and error terms, respectively.   <span>$V_C$</span> is pre-estimated under the null model (<code>H0</code>) of no QTL from the conventional MLMM, which is equivalent to the FlxQTL model for <span>$\tau^2 =1$</span>.   <span>$Z \neq I_m$</span> estimates much smaller <code>B</code> than the former model with <code>Z = I</code>, where  dim(Y) = (m traits, n individuals), and dim(X) = (p markers, n), dim(Z) = (m, q trait covariates).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/FlxQTL.jl/blob/3f98e4000af8f88b3f5d817e824352aa3fbd0019/src/flxMLMM.jl#L2-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FlxQTL.flxMLMM.K2eig" href="#FlxQTL.flxMLMM.K2eig"><code>FlxQTL.flxMLMM.K2eig</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">   K2eig(K,LOCO::Bool=false)</code></pre><p>Returns eigenvectors and eigenvalues of genetic relatedness, or 3-d array of these of a genetic relatedness if <code>LOCO</code> is <code>true</code>.</p><p><strong>Arguments</strong></p><ul><li><code>K</code> : A matrix of genetic relatedness (Default).  3-d array of genetic relatedness (<code>LOCO</code> sets to be true.)</li><li><code>LOCO</code> : Boolean. Default is <code>false</code> (no LOCO). (Leave One Chromosome Out).</li></ul><p><strong>Output</strong></p><ul><li><code>T</code> : A matrix of eigenvectors, or a 3-d array of eigenvectors if <code>LOCO</code> sets to be <code>true</code>.</li><li><code>λ</code> : A vector of eigenvalues, or a matrix of eigenvalues if <code>LOCO</code> sets to be <code>true</code>.</li></ul><p><strong>Examples</strong></p><p>For a null variance component, or genetic relatedness for <code>LOCO =false</code>,</p><pre><code class="language-julia hljs"> T, λ = K2eig(K)
</code></pre><p>produces a matrix of <code>T</code> and a vector of <code>λ</code>.</p><p>For a genetic kinship calculated under <code>LOCO</code> (a 3-d array of kinship matrices),</p><pre><code class="language-julia hljs"> T, λ = K2eig(K,true)
</code></pre><p>produces a 3-d array of matrices <code>T</code> and a matrix of <code>λ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/FlxQTL.jl/blob/3f98e4000af8f88b3f5d817e824352aa3fbd0019/src/transformation.jl#L3-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FlxQTL.flxMLMM.gene2Scan" href="#FlxQTL.flxMLMM.gene2Scan"><code>FlxQTL.flxMLMM.gene2Scan</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gene2Scan(cross::Int64,Tg::Union{Array{Float64,3},Matrix{Float64}},Λg::Union{Matrix{Float64},Vector{Float64}},
          Y::Array{Float64,2},XX::Markers,LOCO::Bool=false;m=size(Y,1),Z=diagm(ones(m)),
          Xnul::Array{Float64,2}=ones(1,size(Y,2)),df_prior=m+1,Prior::Matrix{Float64}=cov(Y,dims=2)*3,
          itol=1e-3,tol0=1e-3,tol::Float64=1e-4,ρ=0.001)

gene2Scan(Tg,Λg,Y,XX,cross,false;m=size(Y,1),Xnul::Array{Float64,2}=ones(1,size(Y,2)),df_prior=m+1,
        Prior::Matrix{Float64}=cov(Y,dims=2)*3,kmin::Int64=1,itol=1e-4,tol0=1e-3,tol::Float64=1e-4,ρ=0.001)</code></pre><p>Implement 2d-genome scan with/without LOCO (Leave One Chromosome Out).  The first function is a FlxQTL model with/without <code>Z</code> that  preestimate a null variance component matrix (<span>$V_C$</span>) under H0 : no QTL, followed by its adjustment by a scalar parameter under H1 : existing QTL.   The third <code>geneScan()</code> is based on a conventional MLMM that estimate all parameters under <code>H0/H1</code>.   The FlxQTL model is defined as </p><p class="math-container">\[vec(Y)\sim MVN((X&#39; \otimes Z)vec(B) (or ZBX), K \otimes \Omega +I \otimes \Sigma),\]</p><p>where <code>K</code> is a genetic kinship, and <span>$\Omega \approx \tau^2V_C$</span>, <span>$\Sigma$</span> are covariance matrices for random and error terms, respectively.   <span>$V_C$</span> is pre-estimated under the null model (<code>H0</code>) of no QTL from the conventional MLMM, which is equivalent to the FlxQTL model for <span>$\tau^2 =1$</span>.  </p><p><strong>Arguments</strong></p><ul><li><code>cross</code> : An integer (Int64) indicating the occurrence of combination of alleles or genotypes. Ex. 2 for RIF, 4 for four-way cross, 8 for HS mouse (allele probabilities), etc.         This value is related to degrees of freedom for the effect size of the genetic marker when doing genome scan.</li><li><code>Tg</code> : A n x n matrix of eigenvectors, or a 3d-array of eigenvectors if <code>LOCO</code> is true.  See also <a href="#FlxQTL.flxMLMM.K2eig"><code>K2eig</code></a>. </li><li><code>Λg</code> : A n x 1 vector of eigenvalues from kinship. Returns a matrix of eigenvalues if <code>LOCO</code> is true.</li><li><code>Y</code> : A m x n matrix of response variables, i.e. m traits by n individuals (or lines). For univariate phenotypes, use square brackets in arguement.       i.e. <code>Y0[1,:]</code> (a vector) -&gt;<code>Y[[1],:]</code> (a matrix) .</li><li><code>XX</code> : A type of <a href="#FlxQTL.Util.Markers"><code>Markers</code></a>.</li><li><code>Z</code> :  An optional m x q matrix of low-dimensional phenotypic covariates, i.e. contrasts, basis functions (wavelet, polynomials, B-splines, etc.).     If no assumption among traits, insert an identity matrix, <code>Matrix(1.0I,m,m)</code>, or use the second <code>geneScan()</code>.  </li><li><code>LOCO</code> : Boolean. Default is <code>false</code> (no LOCO). Runs genome scan using LOCO (Leave One Chromosome Out) if <code>true</code>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>Xnul</code> :  A matrix of covariates. Default is intercepts (1&#39;s): <code>Xnul= ones(1,size(Y,2))</code>.  Adding covariates (C) is <code>Xnul= vcat(ones(1,n),C)</code> where <code>size(C)=(c,n)</code>.</li><li><code>Prior</code>: A positive definite scale matrix, <span>$\Psi$</span>, of prior Inverse-Wishart distributon, i.e. <span>$\Sigma \sim W^{-1}_m (\Psi, \nu_0)$</span>.            An amplified empirical covariance matrix is default.</li><li><code>df_prior</code>: Degrees of freedom, <span>$\nu_0$</span> for Inverse-Wishart distributon.  <code>m+1</code> (weakly informative) is default. </li><li><code>itol</code> :  A tolerance controlling ECM (Expectation Conditional Maximization) under H0: no QTL. Default is <code>1e-3</code>.</li><li><code>tol0</code> :  A tolerance controlling ECM under H1: existence of QTL. Default is <code>1e-3</code>.</li><li><code>tol</code> : A tolerance of controlling Nesterov Acceleration Gradient method under both H0 and H1. Default is <code>1e-4</code>.</li><li><code>ρ</code> : A tunning parameter controlling <span>$\tau^2$</span>. Default is <code>0.001</code>.</li></ul><p>!!! Note</p><ul><li>When some LOD scores return negative values, reduce tolerences for ECM to <code>tol0 = 1e-4</code>, or increase <code>df_prior</code>, such that   <span>$m+1 \le$</span> <code>df_prior</code> <span>$&lt; 2m$</span>.  The easiest setting is <code>df_prior = Int64(ceil(1.9m))</code> for numerical stability.   </li></ul><p><strong>Output</strong></p><ul><li><code>LODs</code> : LOD scores. Can change to <span>$- \log_{10}{P}$</span> using <a href="#FlxQTL.Util.lod2logP-Tuple{Union{Vector{Any}, Vector{Float64}}, Int64}"><code>lod2logP</code></a>.</li><li><code>est0</code> : A type of <code>EcmNestrv.Approx</code> including parameter estimates under H0: no QTL.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/FlxQTL.jl/blob/3f98e4000af8f88b3f5d817e824352aa3fbd0019/src/PgeneScan2D.jl#L77-L134">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FlxQTL.flxMLMM.geneScan" href="#FlxQTL.flxMLMM.geneScan"><code>FlxQTL.flxMLMM.geneScan</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">geneScan(cross::Int64,Tg::Union{Array{Float64,3},Matrix{Float64}},Λg::Union{Matrix{Float64},Vector{Float64}},
         Y::Array{Float64,2},XX::Markers,Z::Array{Float64,2},LOCO::Bool=false;m=size(Y,1),H0_up::Bool=false,
         Xnul::Array{Float64,2}=ones(1,size(Y,2)),df_prior=m+1,Prior::Matrix{Float64}=cov(Y,dims=2)*3,
         LogP::Bool=false,itol=1e-3,tol0=1e-3,tol::Float64=1e-4,ρ=0.001)

geneScan(cross,Tg,Λg,Y,XX,false;m=size(Y,1),H0_up::Bool=false,Xnul::Array{Float64,2}=ones(1,size(Y,2)),
         df_prior=m+1,Prior=cov(Y,dims=2)*3,LogP=false,itol=1e-3,tol0=1e-3,tol=1e-4,ρ=0.001)

geneScan(Tg,Λg,Y,XX,cross,false;Xnul=ones(1,size(Y,2)),df_prior=m+1,Prior=cov(Y,dims=2)*3,LogP=false,
         itol=1e-3,tol0=1e-3,tol=1e-4,ρ=0.001)</code></pre><p>Implement 1d-genome scan with/without LOCO (Leave One Chromosome Out).  The first two functions are FlxQTL models with/without <code>Z</code> that  preestimate a null variance component matrix (<span>$V_C$</span>) under H0 : no QTL, followed by its adjustment by a scalar parameter under H1 : existing QTL.   The third <code>geneScan()</code> is based on a conventional MLMM that estimate all parameters under <code>H0/H1</code>.   The FlxQTL model is defined as </p><p class="math-container">\[vec(Y)\sim MVN((X&#39; \otimes Z)vec(B) (or ZBX), K \otimes \Omega +I \otimes \Sigma),\]</p><p>where <code>K</code> is a genetic kinship, and <span>$\Omega \approx \tau^2V_C$</span>, <span>$\Sigma$</span> are covariance matrices for random and error terms, respectively.   <span>$V_C$</span> is pre-estimated under the null model (<code>H0</code>) of no QTL from the conventional MLMM, which is equivalent to the FlxQTL model for <span>$\tau^2 =1$</span>.  </p><p><strong>Arguments</strong></p><ul><li><code>cross</code> : An integer (Int64) indicating the occurrence of combination of alleles or genotypes. Ex. 2 for RIF, 4 for four-way cross, 8 for HS mouse (allele probabilities), etc.         This value is related to degrees of freedom for the effect size of the genetic marker when doing genome scan.</li><li><code>Tg</code> : A n x n matrix of eigenvectors, or a 3d-array of eigenvectors if <code>LOCO</code> is true.  See also <a href="#FlxQTL.flxMLMM.K2eig"><code>K2eig</code></a>. </li><li><code>Λg</code> : A n x 1 vector of eigenvalues from kinship. Returns a matrix of eigenvalues if <code>LOCO</code> is true.</li><li><code>Y</code> : A m x n matrix of response variables, i.e. m traits by n individuals (or lines). For univariate phenotypes, use square brackets in arguement.       i.e. <code>Y0[1,:]</code> (a vector) -&gt;<code>Y[[1],:]</code> (a matrix) .</li><li><code>XX</code> : A type of <a href="#FlxQTL.Util.Markers"><code>Markers</code></a>.</li><li><code>Z</code> :  An optional m x q matrix of low-dimensional phenotypic covariates, i.e. contrasts, basis functions (wavelet, polynomials, B-splines, etc.).     If no assumption among traits, insert an identity matrix, <code>Matrix(1.0I,m,m)</code>, or use the second <code>geneScan()</code>.  </li><li><code>LOCO</code> : Boolean. Default is <code>false</code> (no LOCO). Runs genome scan using LOCO (Leave One Chromosome Out) if <code>true</code>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>Xnul</code> :  A matrix of covariates. Default is intercepts (1&#39;s): <code>Xnul= ones(1,size(Y,2))</code>.  Adding covariates (C) is <code>Xnul= vcat(ones(1,n),C)</code> where <code>size(C)=(c,n)</code>.</li><li><code>Prior</code>: A positive definite scale matrix, <span>$\Psi$</span>, of prior Inverse-Wishart distributon, i.e. <span>$\Sigma \sim W^{-1}_m (\Psi, \nu_0)$</span>.            An amplified empirical covariance matrix is default.</li><li><code>df_prior</code>: Degrees of freedom, <span>$\nu_0$</span> for Inverse-Wishart distributon.  <code>m+1</code> (weakly informative) is default. </li><li><code>H0_up</code> : Default returns null estimates, <code>est0</code> from the conventional MLMM.  It is recommended setting <code>H0_up=true</code> for <span>$m \ge 11$</span> to avoid negative LODs. </li><li><code>itol</code> :  A tolerance controlling ECM (Expectation Conditional Maximization) under H0: no QTL. Default is <code>1e-3</code>.</li><li><code>tol0</code> :  A tolerance controlling ECM under H1: existence of QTL. Default is <code>1e-3</code>.</li><li><code>tol</code> : A tolerance of controlling Nesterov Acceleration Gradient method under both H0 and H1. Default is <code>1e-4</code>.</li><li><code>ρ</code> : A tunning parameter controlling <span>$\tau^2$</span>. Default is <code>0.001</code>.</li><li><code>LogP</code> : Boolean. Default is <code>false</code>.  Returns <span>$-\log_{10}{P}$</span> instead of LOD scores if <code>true</code>.</li></ul><p>!!! Note</p><ul><li>When some LOD scores return negative values, reduce tolerences for ECM to <code>tol0 = 1e-4</code>, or increase <code>df_prior</code>, such that   <span>$m+1 \le$</span> <code>df_prior</code> <span>$&lt; 2m$</span>.  The easiest setting is <code>df_prior = Int64(ceil(1.9m))</code> for numerical stability.   </li></ul><p><strong>Output</strong></p><ul><li><code>LODs</code> (or <code>logP</code>) : LOD scores. Can change to <span>$- \log_{10}{P}$</span> in <a href="#FlxQTL.Util.lod2logP-Tuple{Union{Vector{Any}, Vector{Float64}}, Int64}"><code>lod2logP</code></a> if <code>LogP = true</code>.</li><li><code>B</code> : A 3-d array of <code>B</code> (fixed effects) matrices under H1: existence of QTL.  If sex covariates, e.g. size(C)=(1,n), are added to <code>Xnul</code> : <code>Xnul= [ones(1,size(Y,2)); C]</code>        in 4-way cross analysis, B[:,2,100], B[:,3:5,100] are effects for sex, the rest genotypes of the 100th QTL, respectively.</li><li><code>est0</code> : A type of <code>EcmNestrv.Result</code> including parameter estimates under H0: no QTL for both functions.  Returns <code>EcmNestrv.Approx</code> if <code>H0_up=true</code> for the FlxQTL model only.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/FlxQTL.jl/blob/3f98e4000af8f88b3f5d817e824352aa3fbd0019/src/geneScan1.jl#L65-L129">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FlxQTL.flxMLMM.permTest-Tuple{Int64, Any, Any, Any, Markers}" href="#FlxQTL.flxMLMM.permTest-Tuple{Int64, Any, Any, Any, Markers}"><code>FlxQTL.flxMLMM.permTest</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">  permTest(nperm::Int64,cross,Kg,Y,XX::Markers;pval=[0.05 0.01],m=size(Y,1),Z=diagm(ones(m)),df_prior=m+1,
          Prior::Matrix{Float64}=cov(Y,dims=2)*3,Xnul=ones(1,size(Y,2)),itol=1e-4,tol0=1e-3,tol=1e-4,ρ=0.001)
  
  mlmmTest(nperm::Int64,cross,Kg,Y,XX::Markers;pval=[0.05 0.01],df_prior=m+1,
           Prior::Matrix{Float64}=cov(Y,dims=2)*3,Xnul=ones(1,size(Y,2)),itol=1e-4,tol0=1e-3,tol=1e-4,ρ=0.001)</code></pre><p>Implement permutation test to get thresholds at the levels of type 1 error, <code>α</code>.  Note that <code>mlmmTest()</code>  is based on the conventional MLMM (<code>Z=I</code>). The FlxQTL model is defined as </p><p class="math-container">\[vec(Y)\sim MVN((X&#39; \otimes Z)vec(B) (or ZBX), K \otimes \Omega +I \otimes \Sigma),\]</p><p>where <code>K</code> is a genetic kinship, and <span>$\Omega \approx \tau^2V_C$</span>, <span>$\Sigma$</span> are covariance matrices for random and error terms, respectively.   <span>$V_C$</span> is pre-estimated under the null model (<code>H0</code>) of no QTL from the conventional MLMM, which is equivalent to the FlxQTL model for <span>$\tau^2 =1$</span>.  </p><p>!!! NOTE</p><ul><li><code>permutationTest()</code> is implemented by <code>geneScan</code> with LOCO.  </li></ul><p><strong>Arguments</strong></p><ul><li><code>nperm</code> : An integer indicating the number of permutation to be implemented.</li><li><code>cross</code> : An integer indicating the number of alleles or genotypes. Ex. <code>2</code> for RIF, <code>4</code> for four-way cross, <code>8</code> for HS mouse (allele probabilities), etc.         This value is related to degree of freedom when doing genome scan.</li><li><code>Kg</code> : A n x n genetic kinship matrix. Should be symmetric positive definite.</li><li><code>Y</code> : A m x n matrix of response variables, i.e. m traits (or environments) by n individuals (or lines). For univariate phenotypes, use square brackets in arguement.       i.e. <code>Y[1,:]</code>  (a vector) -&gt; <code>Y[[1],:]</code>  (a matrix) .</li><li><code>XX</code> : A type of <a href="#FlxQTL.Util.Markers"><code>Markers</code></a>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>pval</code> : A vector of p-values to get their quantiles. Default is <code>[0.05  0.01]</code> (without comma).</li><li><code>Xnul</code> : A matrix of covariates. Default is intercepts (1&#39;s).  Unless plugging in particular covariates, just leave as it is.</li><li><code>Z</code> :  An optional m x q matrix of low-dimensional phenotypic covariates, i.e. contrasts, basis functions (fourier, wavelet, polynomials, B-splines, etc.).        If the data does not assume any particular trait relation, just use <code>Z = I</code> (default).  </li><li><code>Prior</code>: A positive definite scale matrix, <span>$\Psi$</span>, of prior Inverse-Wishart distributon, i.e. <span>$\Sigma \sim W^{-1}_m (\Psi, \nu_0)$</span>.            An amplified empirical covariance matrix is default.</li><li><code>df_prior</code>: Degrees of freedom, <span>$\nu_0$</span> for Inverse-Wishart distributon.  <code>m+1</code> (weakly informative) is default.</li><li><code>itol</code> : A tolerance controlling ECM (Expectation Conditional Maximization) under H0: no QTL. Default is <code>1e-3</code>.</li><li><code>tol0</code> : A tolerance controlling ECM under H1: existence of QTL. Default is <code>1e-3</code>.</li><li><code>tol</code> : A tolerance of controlling Nesterov Acceleration Gradient method under both H0 and H1. Default is <code>1e-4</code>.</li><li><code>ρ</code> : A tunning parameter controlling <span>$\tau^2$</span>. Default is <code>0.001</code>.  </li></ul><p>!!! Note</p><ul><li>When some LOD scores return negative values, reduce tolerences for ECM to <code>tol0 = 1e-4</code>, or increase <code>df_prior</code>, such that   <span>$m+1 \le$</span> <code>df_prior</code> <span>$&lt; 2m$</span>.  The easiest setting is <code>df_prior = Int64(ceil(1.9m))</code> for numerical stability.   </li></ul><p><strong>Output</strong></p><ul><li><code>maxLODs</code> : A nperm x 1 vector of maximal LOD scores by permutation. </li><li><code>H1par_perm</code> : A type of struct, <code>EcmNestrv.Approx(B,τ2,Σ,loglik)</code> including parameter estimates  or <code>EcmNestrv.Result(B,Vc,Σ,loglik)</code>                for a conventional MLMM under H0: no QTL by permutation. </li><li><code>cutoff</code> : A vector of thresholds corresponding to <code>pval</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/FlxQTL.jl/blob/3f98e4000af8f88b3f5d817e824352aa3fbd0019/src/PpermutationTest.jl#L207-L266">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FlxQTL.flxMLMM.permutationTest-Tuple{Int64, Int64, Array{Float64, 3}, Matrix{Float64}, Markers}" href="#FlxQTL.flxMLMM.permutationTest-Tuple{Int64, Int64, Array{Float64, 3}, Matrix{Float64}, Markers}"><code>FlxQTL.flxMLMM.permutationTest</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">  permutationTest(nperm,cross,Kg,Y,XX;pval=[0.05 0.01],Z=diagm(ones(m)),Xnul=ones(1,size(Y,2)),
                 df_prior=m+1,Prior::Matrix{Float64}=cov(Y,dims=2)*3,
                 LOCO_all::Bool=false,itol=1e-4,tol0=1e-3,tol=1e-4,ρ=0.001,δ =0.01)</code></pre><p>Implement permutation test from the distribution of maximum LOD scores by LOCO to get thresholds at the levels of type 1 error, <code>α</code>.   The FlxQTL model is defined as </p><p class="math-container">\[vec(Y)\sim MVN((X&#39; \otimes Z)vec(B) (or ZBX), K \otimes \Omega +I \otimes \Sigma),\]</p><p>where <code>K</code> is a genetic kinship, and <span>$\Omega \approx \tau^2V_C$</span>, <span>$\Sigma$</span> are covariance matrices for random and error terms, respectively.   <span>$V_C$</span> is pre-estimated under the null model (H0) of no QTL from the conventiona MLMM, which is equivalent to the FlxQTL model for <span>$\tau^2 =1$</span>.  </p><p>!!! NOTE</p><ul><li><code>permTest()</code> and <code>mlmmTest()</code> are implemented by <code>geneScan</code> without LOCO.  </li></ul><p><strong>Arguments</strong></p><ul><li><code>nperm</code> : An integer (Int64) indicating the number of permutation to be implemented.</li><li><code>cross</code> : An integer (Int64) indicating the number of combination of alleles or genotypes. Ex. <code>2</code> for RIF, <code>4</code> for four-way cross, <code>8</code> for HS mouse (allele probabilities), etc.         This value is related to degrees of freedom for the effect size of a genetic marker when doing genome scan.</li><li><code>Kg</code> : A 3d-array of n x n genetic kinship matrices. Should be symmetric positive definite.</li><li><code>Y</code> : A m x n matrix of response variables, i.e. m traits (or environments) by n individuals (or lines). For univariate phenotypes, use square brackets in arguement.       i.e. <code>Y[1,:]</code>  (a vector) -&gt; <code>Y[[1],:]</code>  (a matrix) .</li><li><code>XX</code> : A type of <a href="#FlxQTL.Util.Markers"><code>Markers</code></a>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>pval</code> : A vector of p-values to get their quantiles. Default is <code>[0.05  0.01]</code> (without comma).</li><li><code>Xnul</code> : A matrix of covariates. Default is intercepts (1&#39;s).  Unless plugging in particular covariates, just leave as it is.</li><li><code>Z</code> :  An optional m x q matrix of low-dimensional phenotypic covariates, i.e. contrasts, basis functions (wavelet, polynomials, B-splines, etc.).        If the data does not assume any particular trait relation, just use <code>Z = diagm(ones(m)) or Matrix(1.0I,m,m)</code> (default).  </li><li><code>Prior</code>: A positive definite scale matrix, <span>$\Psi$</span>, of prior Inverse-Wishart distributon, i.e. <span>$\Sigma \sim W^{-1}_m (\Psi, \nu_0)$</span>.             An amplified empirical covariance matrix is default.</li><li><code>df_prior</code>: Degrees of freedom, <span>$\nu_0$</span> for Inverse-Wishart distributon.  <code>m+1</code> (weakly informative) is default.</li><li><code>LOCO_all</code> : Boolean. Default is <code>false</code>, which implements <code>geneScan(LOCO=true)</code> with permuted data but a null variance component (<code>Vc</code>) preestimated only once              with a kinship (<a href="#FlxQTL.GRM.kinshipLin-Tuple{Any, Any}"><code>kinshipLin</code></a> for genotype (or allele) probabilities, or <a href="#FlxQTL.GRM.kinshipStd-Tuple{Matrix{Float64}}"><code>kinshipStd</code></a> for genotypes) by <code>LOCO=false</code> implicitly.                It is recommended setting <code>true</code> for higher-dimensional traits for faster convergence and decent accuracy, i.e. approximately <span>$m &gt; 15$</span> depending on the data.</li><li><code>itol</code> : A tolerance controlling ECM (Expectation Conditional Maximization) under H0: no QTL. Default is <code>1e-3</code>.</li><li><code>tol0</code> : A tolerance controlling ECM under H1: existence of QTL. Default is <code>1e-3</code>.</li><li><code>tol</code> : A tolerance of controlling Nesterov Acceleration Gradient method under both H0 and H1. Default is <code>1e-4</code>.</li><li><code>ρ</code> : A tunning parameter controlling <span>$\tau^2$</span>. Default is <code>0.001</code>.  </li><li><code>δ</code> : A tuning parameter to correct a non-positive definite kinship without LOCO to pre-estimate a null variance component for low- to medium-dimensional       traits (<span>$m \le 10 \sim 15$</span>) only.  This <code>no-LOCO</code> kinship is computed inside the function for efficient computation.</li></ul><p>!!! Note</p><ul><li>When some LOD scores return negative values, reduce tolerences for ECM to <code>tol0 = 1e-4</code>, or increase <code>df_prior</code>, such that   <span>$m+1 \le$</span> <code>df_prior</code> <span>$&lt; 2m$</span>.  The easiest setting is <code>df_prior = Int64(ceil(1.9m))</code> for numerical stability.   </li></ul><p><strong>Output</strong></p><ul><li><code>maxLODs</code> : A nperm x 1 vector of maximal LOD scores by permutation. </li><li><code>H1par_perm</code> : A vector of structs, <code>EcmNestrv.Approx(B,τ2,Σ,loglik)</code> for each Chromosome per permutation, i.e. <code># of Chromosomes</code> x <code>nperm</code>.</li><li><code>cutoff</code> : A vector of thresholds corresponding to <code>pval</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/FlxQTL.jl/blob/3f98e4000af8f88b3f5d817e824352aa3fbd0019/src/PpermutationTest1.jl#L274-L334">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FlxQTL.EcmNestrv" href="#FlxQTL.EcmNestrv"><code>FlxQTL.EcmNestrv</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">EcmNestrv</code></pre><p>A module for base algorithms using the ECM (Expectation-Conditional Maxization) with the Speed restarting Nesterov&#39;s accelerated gradient method  to fit a flexible multivariate linear mixed model (flxMLMM).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/FlxQTL.jl/blob/3f98e4000af8f88b3f5d817e824352aa3fbd0019/src/EcmNestrv.jl#L1-L8">source</a></section></article><h2 id="Genetic-Relatedness-Matrices-(GRM)"><a class="docs-heading-anchor" href="#Genetic-Relatedness-Matrices-(GRM)">Genetic Relatedness Matrices (GRM)</a><a id="Genetic-Relatedness-Matrices-(GRM)-1"></a><a class="docs-heading-anchor-permalink" href="#Genetic-Relatedness-Matrices-(GRM)" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FlxQTL.GRM" href="#FlxQTL.GRM"><code>FlxQTL.GRM</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> GRM</code></pre><p>A module for computing Genetic Relatedness Matrix (or kinship).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/FlxQTL.jl/blob/3f98e4000af8f88b3f5d817e824352aa3fbd0019/src/GRM.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FlxQTL.GRM.kinship4way-Tuple{Matrix{Float64}}" href="#FlxQTL.GRM.kinship4way-Tuple{Matrix{Float64}}"><code>FlxQTL.GRM.kinship4way</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> kinship4way(genmat::Array{Float64,2})</code></pre><p>Computes a kinship for four-way cross data counting the occurrence of different alleles between two markers: ex. AB-AB=0; AB-AC=1; AB-CD=2,<span>$\dots$</span> Note: In <a href="https://cran.r-project.org/web/packages/qtl/qtl.pdf">R/qtl</a>, genotypes are labeled as 1=AC; 2=BC; 3=AD; 4=BD by the function, <code>read.cross()</code>.</p><p><strong>Argument</strong></p><ul><li><code>genmat</code> : A matrix of genotypes for <code>four-way cross</code> <span>$(1,2, \dots)$</span>.          size(genematrix)= (p,n), for <code>p</code> genetic markers x <code>n</code> individuals(or lines).</li></ul><p><strong>Output</strong></p><p>Returns a n x n symmetric matrix containing 1&#39;s on the diagonal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/FlxQTL.jl/blob/3f98e4000af8f88b3f5d817e824352aa3fbd0019/src/GRM.jl#L63-L80">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FlxQTL.GRM.kinshipCtr-Tuple{Matrix{Float64}}" href="#FlxQTL.GRM.kinshipCtr-Tuple{Matrix{Float64}}"><code>FlxQTL.GRM.kinshipCtr</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> kinshipCtr(genmat::Array{Float64,2})</code></pre><p>Calculates a kinship with a centered genotype matrix (linear kernel), where a marker mean is subtracted from its genotypes.</p><p><strong>Argument</strong></p><ul><li><code>genmat</code> : A matrix of genotype data (0,1,2). size(genmat)=(p,n) for <code>p</code> markers x <code>n</code> individuals</li></ul><p><strong>Output</strong></p><p>Returns a n x n symmetric matrix. See also <a href="#FlxQTL.GRM.kinshipStd-Tuple{Matrix{Float64}}"><code>kinshipStd</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/FlxQTL.jl/blob/3f98e4000af8f88b3f5d817e824352aa3fbd0019/src/GRM.jl#L141-L156">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FlxQTL.GRM.kinshipGK-Tuple{Matrix{Float64}, Float64}" href="#FlxQTL.GRM.kinshipGK-Tuple{Matrix{Float64}, Float64}"><code>FlxQTL.GRM.kinshipGK</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> kinshipGK(G::Array{Float64,2},ρ::Float64)</code></pre><p>Computes a non-linear kinship matrix using a Gaussian Kernel.</p><p><strong>Arguments</strong></p><ul><li><code>G</code> : A matrix of genotype. size(G)=(r,c), such that <code>r</code> genotype markers and <code>c</code> individuals (or lines).</li><li><code>ρ</code> : A free parameter determining the width of the kernel. Could be attained empirically.</li></ul><p><strong>Output</strong></p><p>Returns a c x c symmetric (positive definite) matrix containing 1&#39;s on the diagonal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/FlxQTL.jl/blob/3f98e4000af8f88b3f5d817e824352aa3fbd0019/src/GRM.jl#L110-L125">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FlxQTL.GRM.kinshipLin-Tuple{Any, Any}" href="#FlxQTL.GRM.kinshipLin-Tuple{Any, Any}"><code>FlxQTL.GRM.kinshipLin</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">kinshipLin(mat,cross)</code></pre><p>Calculates a kinship matrix by linear kernel for genotype (or allele) probabilities.  This is a general form of      <a href="#FlxQTL.GRM.kinshipCtr-Tuple{Matrix{Float64}}"><code>kinshipCtr</code></a>, <a href="#FlxQTL.GRM.kinshipStd-Tuple{Matrix{Float64}}"><code>kinshipStd</code></a> for genetype data, i.e. <code>XX&#39;</code>.  </p><p><strong>Arguments</strong></p><ul><li><code>mat</code> : A matrix of genotype (or allele) probabilities usually extracted from <a href="https://rqtl.org/tutorials/rqtltour.pdf">R/qtl</a>,       <a href="https://kbroman.org/qtl2/assets/vignettes/user_guide.html">R/qtl2</a>, or the counterpart packages. size(mat)= (p,n) for p genetic markers x n individuals.</li><li><code>cross</code> (&gt;1) : An integer indicating the occurrence or combination of alleles or genotypes in a genetic marker.                ex. 1 for genotypes (labeled as 0,1,2), 2 for RIF, 4 for four-way cross, 8 for HS mouse (allele probabilities), etc.</li></ul><p><strong>Output</strong></p><p>Returns a n x n symmetric (positive definite) matrix containing 1&#39;s on the diagonal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/FlxQTL.jl/blob/3f98e4000af8f88b3f5d817e824352aa3fbd0019/src/GRM.jl#L198-L217">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FlxQTL.GRM.kinshipLoco" href="#FlxQTL.GRM.kinshipLoco"><code>FlxQTL.GRM.kinshipLoco</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> kinshipLoco(kin,g::Markers,cross::Int64=1,ρ=0.01)</code></pre><p>Generates a 3-d array of symmetric positive definite kinship matrices using LOCO (Leave One Chromosome Out) witout shrinkage intensity estimation.   This is designed for linear kernel based kinship functions. See Arguments.</p><p><strong>Arguments</strong></p><ul><li><code>kin</code> :  A function of computing a kinship. Can only use with <a href="#FlxQTL.GRM.kinshipCtr-Tuple{Matrix{Float64}}"><code>kinshipCtr</code></a>, <a href="#FlxQTL.GRM.kinshipStd-Tuple{Matrix{Float64}}"><code>kinshipStd</code></a> for genotypes, and with <a href="#FlxQTL.GRM.kinshipLin-Tuple{Any, Any}"><code>kinshipLin</code></a>         for genotype (or allele) probabilities.</li><li><code>g</code>   : A struct of arrays, type  <a href="#FlxQTL.Util.Markers"><code>Markers</code></a>.</li><li><code>cross</code> :  A scalar indicating the occurrence or combination of alleles or genotypes in a genetic marker.  Simply, it coincides with the number of columns per marker in genotype            (or allele) probability data; for instance, 1 for genotypes (0,1,2) as default, 2 for RIF, 4 for four-way cross, 8 for HS mouse (allele probabilities), etc.</li><li><code>ρ</code>  :  A real number to correct a non-positive definite kinship.  Default is 0.01.  When a kinship is not corrected to be positive definite with          the default value, slight increase of <code>ρ</code> can adjust to minuscule negative eigenvalues.</li></ul><p><strong>Output</strong></p><p>Returns a 3-d array of n x n symmetric positive definite matrices as many as Chromosomes. Refer to <a href="#FlxQTL.GRM.shrinkgLoco-Tuple{Any, Int64, Markers}"><code>shrinkgLoco</code></a> for comparison.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/FlxQTL.jl/blob/3f98e4000af8f88b3f5d817e824352aa3fbd0019/src/GRM.jl#L360-L383">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FlxQTL.GRM.kinshipMan-Tuple{Matrix{Float64}}" href="#FlxQTL.GRM.kinshipMan-Tuple{Matrix{Float64}}"><code>FlxQTL.GRM.kinshipMan</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">  kinshipMan(genematrix::Array{Float64,2})</code></pre><p>Calculates a kinship matrix using a manhattan distance method. Missing values need to be either omitted or imputed. This function is designed for recombinant inbred line (RIL) (AA/BB), not for 4-way cross genotype data.  See <a href="#FlxQTL.GRM.kinship4way-Tuple{Matrix{Float64}}"><code>kinship4way</code></a>.</p><p><strong>Argument</strong></p><ul><li><code>genematrix</code> : A matrix of genotypes, i.e. 0,1 (or 1,2).  size(genematrix)= (p,n) for <code>p</code> genetic markers x <code>n</code> individuals(or lines).</li></ul><p><strong>Output</strong></p><p>Returns a n x n symmetric matrix containing 1&#39;s on the diagonal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/FlxQTL.jl/blob/3f98e4000af8f88b3f5d817e824352aa3fbd0019/src/GRM.jl#L23-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FlxQTL.GRM.kinshipStd-Tuple{Matrix{Float64}}" href="#FlxQTL.GRM.kinshipStd-Tuple{Matrix{Float64}}"><code>FlxQTL.GRM.kinshipStd</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> kinshipStd(genmat::Array{Float64,2})</code></pre><p>Produces a kinship with a standardized (or normalized) genotype matrix (linear kernel), i.e., centered genetypes divided  by the standard deviation of a marker. </p><p><strong>Argument</strong></p><ul><li><code>genmat</code> : A matrix of genotype data (0,1,2). size(genmat)=(p,n) for <code>p</code> markers x <code>n</code> individuals</li></ul><p><strong>Output</strong></p><p>Returns a n x n symmetric matrix. See also <a href="#FlxQTL.GRM.kinshipCtr-Tuple{Matrix{Float64}}"><code>kinshipCtr</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/FlxQTL.jl/blob/3f98e4000af8f88b3f5d817e824352aa3fbd0019/src/GRM.jl#L169-L187">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FlxQTL.GRM.shrinkg-Tuple{Any, Int64, Any}" href="#FlxQTL.GRM.shrinkg-Tuple{Any, Int64, Any}"><code>FlxQTL.GRM.shrinkg</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> shrinkg(f,nb::Int64,geno)</code></pre><p>Estimates a full-rank positive definite kinship matrix by shrinkage intensity estimation (bootstrap).  Can only use with <a href="#FlxQTL.GRM.kinshipMan-Tuple{Matrix{Float64}}"><code>kinshipMan</code></a>, <a href="#FlxQTL.GRM.kinship4way-Tuple{Matrix{Float64}}"><code>kinship4way</code></a>. This function runs fast by CPU parallelization.  Add workers/processes using an <code>addprocs()</code> function before running it for speedup.</p><p><strong>Arguments</strong></p><ul><li><code>f</code>: A function of computing a kinship. Can only use with <a href="#FlxQTL.GRM.kinshipMan-Tuple{Matrix{Float64}}"><code>kinshipMan</code></a>, <a href="#FlxQTL.GRM.kinship4way-Tuple{Matrix{Float64}}"><code>kinship4way</code></a>.</li><li><code>nb</code> : An integer indicating the number of bootstrap. It does not have to be a large number.</li><li><code>geno</code> : A matrix of genotypes. size(geno) = (p,n) for <code>p</code> markers x <code>n</code> individuals.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; using FlxQTL
julia&gt; addprocs(8)
julia&gt; K = shinkage(kinshipMan,20,myGeno)</code></pre><p><strong>Output</strong></p><p>Returns a full-rank symmetric positive definite matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/FlxQTL.jl/blob/3f98e4000af8f88b3f5d817e824352aa3fbd0019/src/GRM.jl#L231-L256">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FlxQTL.GRM.shrinkgLoco-Tuple{Any, Int64, Markers}" href="#FlxQTL.GRM.shrinkgLoco-Tuple{Any, Int64, Markers}"><code>FlxQTL.GRM.shrinkgLoco</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">   shrinkgLoco(kin,nb,g::Markers)</code></pre><p>Generates a 3-d array of full-rank positive definite kinship matrices by shrinkage intensity estimation (bootstrap) using a LOCO (Leave One Chromosome Out) scheme. Can only use with <a href="#FlxQTL.GRM.kinshipMan-Tuple{Matrix{Float64}}"><code>kinshipMan</code></a>, <a href="#FlxQTL.GRM.kinship4way-Tuple{Matrix{Float64}}"><code>kinship4way</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>kin</code> :  A function of computing a kinship. Can only use with <a href="#FlxQTL.GRM.kinshipMan-Tuple{Matrix{Float64}}"><code>kinshipMan</code></a>, <a href="#FlxQTL.GRM.kinship4way-Tuple{Matrix{Float64}}"><code>kinship4way</code></a></li><li><code>nb</code> : An integer indicating the number of bootstrap.</li><li><code>g</code> : A struct of arrays, type <a href="#FlxQTL.Util.Markers"><code>Markers</code></a>.</li></ul><p><strong>Output</strong></p><p>Returns 3-d array of n x n symmetric positive definite matrices as many as Chromosomes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/FlxQTL.jl/blob/3f98e4000af8f88b3f5d817e824352aa3fbd0019/src/GRM.jl#L318-L337">source</a></section></article><h2 id="Flexible-Multivariate-Linear-Models-(flxMLM)"><a class="docs-heading-anchor" href="#Flexible-Multivariate-Linear-Models-(flxMLM)">Flexible Multivariate Linear Models (flxMLM)</a><a id="Flexible-Multivariate-Linear-Models-(flxMLM)-1"></a><a class="docs-heading-anchor-permalink" href="#Flexible-Multivariate-Linear-Models-(flxMLM)" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FlxQTL.flxMLM" href="#FlxQTL.flxMLM"><code>FlxQTL.flxMLM</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">flxMLM</code></pre><p>A module designed for fitting a Multivariate Linear Model by the (Residual) Maximum Likelihood (REML or MLE) method.   The model:</p><p><span>$Y=XBZ&#39;+E$</span>, </p><p>where <span>$E(vec(Y))= (Z \otimes X)vec(B)$</span>,  <span>$Var(vec(Y))=  \Sigma \otimes I_n$</span>,</p><p>dim(Y)= (n individuals, m traits), dim(X) = (n,p markers), and dim(Z) = (m, q trait covariates).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/FlxQTL.jl/blob/3f98e4000af8f88b3f5d817e824352aa3fbd0019/src/flxMLM.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FlxQTL.flxMLM.mlm1Scan" href="#FlxQTL.flxMLM.mlm1Scan"><code>FlxQTL.flxMLM.mlm1Scan</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mlm1Scan(cross::Int64,Y::Matrix{Float64},XX::Markers,Z::Matrix{Float64},reml::Bool=false;LogP::Bool=false,
          Xnul::Matrix{Float64}=ones(size(Y,1),1))
mlm1Scan(cross::Int64,Y::Matrix{Float64},XX::Markers,reml::Bool=false;LogP::Bool=false,
          Xnul::Matrix{Float64}=ones(size(Y,1),1))</code></pre><p>Implement 1d-genome scan.  The second <code>mlm1Scan()</code> is for <code>Z=I</code> case;  one can also run the first by inserting an identity matrix (<code>Matrix(1.0I,m,m)</code>) into <code>Z</code>.</p><p><span>$vec(Y) \sim MVN ((Z \otimes X)vec(B) (or XBZ&#39;), \Sigma \otimes I_n),$</span></p><p>where size(Y)=(n,m), size(X)=(n,p), and size(Z)=(m,q).</p><p><strong>Arguments</strong></p><ul><li><code>cross</code> : An integer indicating the occurrence of alleles or genotypes. ex. 2 for RIF, 4 for four-way cross, 8 for HS mouse (allele probabilities), etc.         This value is related to degree of freedom when doing genome scan.</li><li><code>Y</code> : A n x m matrix of response variables, i.e. n individuals (or lines) by m traits (or environments). For univariate phenotypes, use square brackets in the arguement.       i.e. <code>Y0[:,1]</code> (a vector) -&gt;<code>Y[:,[1]]</code> (a matrix) .</li><li><code>XX</code> : A type of <a href="#FlxQTL.Util.Markers"><code>Markers</code></a>. Be cautious when combining genotype infomation into the struct of <code>Markers</code>; <code>size(X) = (n,p)</code>.</li><li><code>Z</code> :  An optional m x q matrix of low-dimensional phenotypic (or trait) covariates, i.e. contrasts, basis functions (fourier, wavelet, polynomials, B-splines, etc.).       If the data does not assume any particular trait relation, just use <code>Z = I</code>.  </li><li><code>reml</code>: Boolean.  Default is fitting the model via mle. Resitricted MLE is implemented if <code>true</code>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>Xnul</code> :  A matrix of covariates. Default is intercepts (1&#39;s): <code>Xnul= ones(size(Y,1),1)</code>.  Adding covariates (C) is <code>Xnul= hcat(ones(n),C)</code> where <code>size(C)=(c,n)</code> for <code>n = size(Y,1)</code>.</li><li><code>LogP</code> : Boolean. Default is <code>false</code>.  Returns <span>$-\log_{10}{P}$</span> instead of LOD scores if <code>true</code>.</li></ul><p><strong>Output</strong></p><ul><li><code>LODs</code> (or <code>logP</code>) : LOD scores. Can change to <span>$- \log_{10}{P}$</span> in <a href="#FlxQTL.Util.lod2logP-Tuple{Union{Vector{Any}, Vector{Float64}}, Int64}"><code>lod2logP</code></a> if <code>LogP = true</code>.</li><li><code>B</code> : A 3-d array of <code>B</code> (fixed effects) matrices under H1: existence of QTL.  If covariates are added to <code>Xnul</code> : <code>Xnul= [ones(size(Y,1)) Covariates]</code>,       ex. For sex covariates in 4-way cross analysis, B[2,:,100], B[3:5,:,100] are effects for sex, the rest genotypes of the 100th QTL, respectively.</li><li><code>est0</code> : A type of <code>MLM.Estimat</code> including parameter estimates under H0: no QTL.              </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/FlxQTL.jl/blob/3f98e4000af8f88b3f5d817e824352aa3fbd0019/src/geneScan.jl#L112-L149">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FlxQTL.flxMLM.mlm2Scan" href="#FlxQTL.flxMLM.mlm2Scan"><code>FlxQTL.flxMLM.mlm2Scan</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> mlm2Scan(cross::Int64,Y::Matrix{Float64},XX::Markers,Z::Matrix{Float64},reml::Bool=false;Xnul::Matrix{Float64}=ones(size(Y,1),1))
 mlm2Scan(cross::Int64,Y::Matrix{Float64},XX::Markers,reml::Bool=false;Xnul::Matrix{Float64}=ones(size(Y,1),1))</code></pre><p>Implement 2d-genome scan.  The second <code>mlm2Scan()</code> is for <code>Z=I</code> case;  one can also run the first by inserting an identity matrix (<code>Matrix(1.0I,m,m)</code>) into <code>Z</code>.</p><p><span>$vec(Y) \sim MVN ((Z \otimes X)vec(B) (or XBZ&#39;), \Sigma \otimes I_n),$</span></p><p>where size(Y)=(n,m), size(X)=(n,p), and size(Z)=(m,q).</p><p><strong>Arguments</strong></p><ul><li><code>cross</code> : An integer indicating the number of alleles or genotypes. Ex. 2 for RIF, 4 for four-way cross, 8 for HS mouse (allele probabilities), etc.         This value is related to degree of freedom when doing genome scan.</li><li><code>Y</code> : A n x m matrix of response variables, i.e. n individuals (or lines) by m traits (or environments). For univariate phenotypes, use square brackets in arguement.       i.e. <code>Y0[:,1]</code> (a vector) -&gt;<code>Y[:,[1]]</code> (a matrix) .</li><li><code>XX</code> : A type of <a href="#FlxQTL.Util.Markers"><code>Markers</code></a>.  Be cautious when combining genotype infomation into the struct of <code>Markers</code>; <code>size(X) = (n,p)</code>.</li><li><code>Z</code> :  An optional m x q matrix of low-dimensional phenotypic covariates, i.e. contrasts, basis functions (fourier, wavelet, polynomials, B-splines, etc.).      If the data does not assume any particular trait relation, just use <code>Z = I</code>.  </li><li><code>reml</code>: Boolean.  Default is fitting the model via mle. Resitricted MLE is implemented if <code>true</code>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>Xnul</code> :  A matrix of covariates. Default is intercepts (1&#39;s).  Unless adding covariates, just leave as it is.  See <a href="#FlxQTL.flxMLM.mlm1Scan"><code>mlm1Scan</code></a>.</li></ul><p><strong>Output</strong></p><ul><li><code>LODs</code> : LOD scores. Can change to <span>$- \log_{10}{P}$</span> using <a href="#FlxQTL.Util.lod2logP-Tuple{Union{Vector{Any}, Vector{Float64}}, Int64}"><code>lod2logP</code></a>.</li><li><code>est0</code> : A type of <code>MLM.Estimat</code> including parameter estimates under H0: no QTL.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/FlxQTL.jl/blob/3f98e4000af8f88b3f5d817e824352aa3fbd0019/src/geneScan.jl#L211-L244">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FlxQTL.flxMLM.mlmTest" href="#FlxQTL.flxMLM.mlmTest"><code>FlxQTL.flxMLM.mlmTest</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> mlmTest(nperm::Int64,cross::Int64,Y::Matrix{Float64},XX::Markers,Z::Matrix{Float64},reml::Bool=false;
          Xnul::Matrix{Float64}=ones(size(Y,1),1),pval=[0.05 0.01])
 mlmTest(nperm::Int64,cross::Int64,Y::Matrix{Float64},XX::Markers,reml::Bool=false;
          Xnul::Matrix{Float64}=ones(size(Y,1),1),pval=[0.05 0.01])</code></pre><p>Implement permutation test to get thresholds at the levels of type 1 error, <code>α</code>.  The second <code>mlmTest()</code> is for <code>Z=I</code> case;  one can also run the first by inserting an identity matrix (<code>Matrix(1.0I,m,m)</code>) into <code>Z</code>.</p><p><span>$vec(Y) \sim MVN ((Z \otimes X)vec(B) (or XBZ&#39;), \Sigma \otimes I_n),$</span></p><p>where size(Y)=(n,m), size(X)=(n,p), and size(Z)=(m,q).</p><p><strong>Arguments</strong></p><ul><li><code>nperm</code> : An integer indicating the number of permutation to be implemented.</li><li><code>cross</code> : An integer indicating the incidence of alleles or genotypes per marker. Ex. <code>2</code> for RIF, <code>4</code> for four-way cross, <code>8</code> for HS mouse (allele probabilities), etc.         This value is related to degree of freedom when doing genome scan.</li><li><code>Y</code> : A n x m matrix of response variables, i.e. n individuals (or lines) by m traits (or environments). For univariate phenotypes, use square brackets in arguement.       i.e. <code>Y[:,1]</code>  (a vector) -&gt; <code>Y[:,[1]]</code>  (a matrix) .</li><li><code>XX</code> : A type of <a href="#FlxQTL.Util.Markers"><code>Markers</code></a>.  Be cautious when combining genotype infomation into the struct of <code>Markers</code>; <code>size(X) = (n,p)</code>.</li><li><code>reml</code>: Boolean.  Default is fitting the model via mle. Resitricted MLE is implemented if <code>true</code>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>pval</code> : A vector of p-values to get their quantiles. Default is <code>[0.05  0.01]</code> (without comma).</li><li><code>Xnul</code> : A matrix of covariates. Default is intercepts (1&#39;s).  Unless plugging in particular covariates, just leave as it is.</li><li><code>Z</code> :  An optional m x q matrix of low-dimensional phenotypic covariates, i.e. contrasts, basis functions (fourier, wavelet, polynomials, B-splines, etc.).        If the data does not assume any particular trait relation, just use <code>Z = I</code>.  </li></ul><p><strong>Output</strong></p><ul><li><p><code>maxLODs</code> : A nperm x 1 vector of maximal LOD scores by permutation. </p></li><li><p><code>H1par_perm</code> : A type of struct, <code>MLM.Estimat(B,Σ,loglik)</code> including parameter estimates                 for a MLM under H0: no QTL by permutation. </p></li><li><p><code>cutoff</code> : A vector of thresholds corresponding to <code>pval</code>.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/FlxQTL.jl/blob/3f98e4000af8f88b3f5d817e824352aa3fbd0019/src/geneScan.jl#L302-L344">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FlxQTL.MLM" href="#FlxQTL.MLM"><code>FlxQTL.MLM</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">  MLM</code></pre><p>A module for fitting general Multivariate Linear Models motivated by functional data analysis via mle or reml. The default fitting method is mle. ( i.e. reml=false)</p><p>The model:  <span>$Y=XBZ&#39;+E$</span>, </p><p>where <span>$E(Y)=XBZ&#39;$</span> (or <span>$E(vec(Y))= (Z \otimes X)vec(B)$</span> ),  </p><p><span>$var(vec(E))=\Sigma \otimes I,$</span></p><p>and size(Y)=(n,m), size(X)=(n,p), and size(Z)=(m,q).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/FlxQTL.jl/blob/3f98e4000af8f88b3f5d817e824352aa3fbd0019/src/MLM.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FlxQTL.MLM.Estimat" href="#FlxQTL.MLM.Estimat"><code>FlxQTL.MLM.Estimat</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> Estimat(B::Array{Float64,2},Σ::Array{Float64,2},loglik::Float64)</code></pre><p>A struct of arrays for results by fitting a multivariate linear model,  <code>mGLM()</code>.   It includes <code>B</code>(fixed effects), <code>Σ</code> (m x m covariance matrix), <code>loglik</code>(a value of log-likelihood by mle or reml).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/FlxQTL.jl/blob/3f98e4000af8f88b3f5d817e824352aa3fbd0019/src/MLM.jl#L222-L229">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FlxQTL.MLM.mGLM" href="#FlxQTL.MLM.mGLM"><code>FlxQTL.MLM.mGLM</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">  mGLM(Y::Array{Float64,2},X::Array{Float64,2},Z::Array{Float64,2},reml::Bool=false)
  mGLM(Y::Array{Float64,2},X::Array{Float64,2},reml::Bool=false)</code></pre><p>Fitting multivariate General Linear Models via MLE (or REML) and returns a type of a struct <code>Estimat</code>.  </p><p><strong>Arguments</strong></p><ul><li><code>Y</code> : A matrix of response variables, i.e. traits. size(Y)=(n,m) for n individuals x m traits</li><li><code>X</code> : A matrix of independent variables, i.e. genotypes or genotype probabilities including intercept or/and covariates. size(X)=(n,p) for n individuals x p markers      including intercept or/and covariates </li><li><code>Z</code> : An optional matrix of low-dimensional phenotypic or trait covariates, i.e. contrasts, basis functions (fourier, wavelet, polynomials, B-splines, etc.).        size(Z)=(m,q) for m traits x q phenotypic covariates.  If the data does not assume any particular trait relation, just use <code>Z = Matrix(1.0I,m,m)</code> or the second functon.  </li><li><code>reml</code> : Boolean. Default is fitting the model via mle. Resitricted MLE is implemented if <code>true</code>. </li></ul><p><strong>Output</strong></p><p>Returns <a href="#FlxQTL.MLM.Estimat"><code>Estimat</code></a> .</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/FlxQTL.jl/blob/3f98e4000af8f88b3f5d817e824352aa3fbd0019/src/MLM.jl#L131-L153">source</a></section></article><h2 id="Utility-Functions-(Util)"><a class="docs-heading-anchor" href="#Utility-Functions-(Util)">Utility Functions (Util)</a><a id="Utility-Functions-(Util)-1"></a><a class="docs-heading-anchor-permalink" href="#Utility-Functions-(Util)" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FlxQTL.Util" href="#FlxQTL.Util"><code>FlxQTL.Util</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> Util</code></pre><p>A module for utility functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/FlxQTL.jl/blob/3f98e4000af8f88b3f5d817e824352aa3fbd0019/src/Miscellanea.jl#L2-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FlxQTL.Util.Markers" href="#FlxQTL.Util.Markers"><code>FlxQTL.Util.Markers</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Markers(name::Array{String,1},chr::Array{Any,1},pos::Array{Float64,1},X::Array{Float64,2})</code></pre><p>A struct of arrays creating genotype or genotype probability data for genome scan.</p><p><strong>Arguments</strong></p><ul><li><code>name</code> : A vector of marker names</li><li><code>chr</code>  : A vector of Chromosomes</li><li><code>pos</code>  : A vector of marker positions (cM)</li><li><code>X</code> : A matrix of genotypes or genotype probabilities</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/FlxQTL.jl/blob/3f98e4000af8f88b3f5d817e824352aa3fbd0019/src/Miscellanea.jl#L53-L66">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FlxQTL.Util.Y_huber-Tuple{Matrix{Float64}}" href="#FlxQTL.Util.Y_huber-Tuple{Matrix{Float64}}"><code>FlxQTL.Util.Y_huber</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Y_huber(Y::Array{Float64,2})</code></pre><p>Rescale Y (phenotype or trait data) to be less sensitive to outliers using by Huber loss function and MAD (median absolute deviation).  size(Y)=(m,n) for <code>m</code> trait and <code>n</code> individuals.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/FlxQTL.jl/blob/3f98e4000af8f88b3f5d817e824352aa3fbd0019/src/Miscellanea.jl#L351-L358">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FlxQTL.Util.array2mat-Tuple{Int64, Array{Float64, 3}}" href="#FlxQTL.Util.array2mat-Tuple{Int64, Array{Float64, 3}}"><code>FlxQTL.Util.array2mat</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> array2mat(cross::Int64,X0::Array{Float64,3})</code></pre><p>Returns a 3-d array to a matrix of genotype probabilities. size(X0)=(cross,n,p) –&gt; (p1,n), where <code>p1</code> = <code>cross*p</code> for <code>p</code> markers,  <code>cross</code> alleles or genotypes, and <code>n</code> individuals. See <a href="#FlxQTL.Util.mat2array-Tuple{Int64, Any}"><code>mat2array</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/FlxQTL.jl/blob/3f98e4000af8f88b3f5d817e824352aa3fbd0019/src/Miscellanea.jl#L141-L149">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FlxQTL.Util.getFinoidx-Tuple{Matrix{Union{Missing, Float64}}}" href="#FlxQTL.Util.getFinoidx-Tuple{Matrix{Union{Missing, Float64}}}"><code>FlxQTL.Util.getFinoidx</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getFinoidx(phenoData::Array{Union{Missing,Float64},2})</code></pre><p>Attains indices of phenotype data without missing values.</p><p><strong>Argument</strong></p><ul><li><code>phenoData</code> : A matrix of phenotype (or trait) data including missing values. size(phenoData) = (m,n) for <code>m</code> traits and <code>n</code> individuals.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/FlxQTL.jl/blob/3f98e4000af8f88b3f5d817e824352aa3fbd0019/src/Miscellanea.jl#L224-L234">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FlxQTL.Util.getGenoidx" href="#FlxQTL.Util.getGenoidx"><code>FlxQTL.Util.getGenoidx</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getGenoidx(GenoData::Union{Array{Any,2},Array{Float64,2}},maf::Float64=0.025)</code></pre><p>Attains genotype indices to drop correlated or bad markers.</p><p><strong>Arguments</strong></p><ul><li><code>GenoData</code> : A matrix of genotype data. size(GenoData)= (p,n) for <code>p</code> markers and <code>n</code> individuals.</li><li><code>maf</code> : A scalar for dropping criterion of markers. Default is <code>0.025</code> i.e. markers of MAF &lt; 0.025 are dropped.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/FlxQTL.jl/blob/3f98e4000af8f88b3f5d817e824352aa3fbd0019/src/Miscellanea.jl#L203-L213">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FlxQTL.Util.lod2logP-Tuple{Union{Vector{Any}, Vector{Float64}}, Int64}" href="#FlxQTL.Util.lod2logP-Tuple{Union{Vector{Any}, Vector{Float64}}, Int64}"><code>FlxQTL.Util.lod2logP</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lod2logP(LODs::Union{Array{Float64,1},Array{Any,1}},v::Int64)</code></pre><p>Caculates <span>$-\log_{10}{P}$</span> from LOD scores.</p><p><strong>Arguments</strong></p><ul><li><code>LODs</code> : A vector of LOD scores computed from genome scan.</li><li><code>v</code> : Degrees of freedom for Chi-squared distribution.  </li></ul><p>!!! NOTE</p><ul><li>To compute degrees of freedom for 1D-genome scan (<code>geneScan</code>), <code>v = prod(size(B1))-prod(size(B0)</code>, where <code>B1</code> and <code>B0</code> are effect size matrices under H1 of a full model (intercept + covariates + QTL) and H0 of no QTL (intercept + covariates), respectively.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/FlxQTL.jl/blob/3f98e4000af8f88b3f5d817e824352aa3fbd0019/src/Miscellanea.jl#L243-L256">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FlxQTL.Util.mat2array-Tuple{Int64, Any}" href="#FlxQTL.Util.mat2array-Tuple{Int64, Any}"><code>FlxQTL.Util.mat2array</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> mat2array(cross::Int64,X0)</code></pre><p>Returns a matrix of genotype probabilities to 3-d array. size(X0)=(p1,n) –&gt; (cross,n,p), where <code>p1</code> = <code>cross*p</code> for <code>p</code> markers,  <code>cross</code> alleles or genotypes, and <code>n</code> individuals.</p><p><strong>Argument</strong></p><ul><li><code>cross</code> : An integer indicating the number of alleles or genotypes. Ex. 2 for RIF, 4 for four-way cross, 8 for HS mouse (allele probabilities), etc.</li><li><code>X0</code> : A matrix of genotype probability data computed from r/qtl or r/qtl2.  </li></ul><p>See <a href="#FlxQTL.Util.array2mat-Tuple{Int64, Array{Float64, 3}}"><code>array2mat</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/FlxQTL.jl/blob/3f98e4000af8f88b3f5d817e824352aa3fbd0019/src/Miscellanea.jl#L116-L130">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FlxQTL.Util.mat2vec-Tuple{Any}" href="#FlxQTL.Util.mat2vec-Tuple{Any}"><code>FlxQTL.Util.mat2vec</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> mat2vec(mat)</code></pre><p>Stacks a matrix to a vector, i.e. vectorizing a matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/FlxQTL.jl/blob/3f98e4000af8f88b3f5d817e824352aa3fbd0019/src/Miscellanea.jl#L98-L104">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FlxQTL.Util.newMarkers" href="#FlxQTL.Util.newMarkers"><code>FlxQTL.Util.newMarkers</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">newMarkers(XX::Markers,cross::Int64,cM::Int64=2)</code></pre><p>Returns a struct of Markers by keeping only markers positioned in every <code>cM</code> centimorgans      for any genome scan to avoid singularity.</p><p><strong>Arguments</strong></p><ul><li><code>XX</code> : A type of <code>Markers</code>. See <a href="#FlxQTL.Util.Markers"><code>Markers</code></a>.</li><li><code>cross</code> : An integer indicating the number of alleles or genotypes. Ex. 2 for RIF, 4 for four-way cross, 8 for HS mouse (allele probabilities), etc.</li><li><code>cM</code> : An integer of dropping criterion of markers. Default is 2, i.e. keeping only markers in every 2 cM, or dropping markers within 2cM between 2 markers.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/FlxQTL.jl/blob/3f98e4000af8f88b3f5d817e824352aa3fbd0019/src/Miscellanea.jl#L311-L324">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FlxQTL.Util.ordrMarkers-Tuple{Matrix{Any}}" href="#FlxQTL.Util.ordrMarkers-Tuple{Matrix{Any}}"><code>FlxQTL.Util.ordrMarkers</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ordrMarkers(markers::Array{Any,2})</code></pre><p>Rearrange by CPU parallelization marker information composed of marker name, chr, position obtained from rqtl2, which is not listed in order (excluding <code>X</code> chromosome).</p><p><strong>Argument</strong></p><ul><li><code>markers</code> : An array of marker information.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/FlxQTL.jl/blob/3f98e4000af8f88b3f5d817e824352aa3fbd0019/src/Miscellanea.jl#L76-L86">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FlxQTL.Util.setSeed-Tuple{Int64}" href="#FlxQTL.Util.setSeed-Tuple{Int64}"><code>FlxQTL.Util.setSeed</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">setSeed(seedNum::Int64)</code></pre><p>Assigns different numbers of seeds to workers (or processes) for reproducibility.</p><p><strong>Arguments</strong></p><ul><li><code>seedNum</code>: An integer.  A minimum seed number to assign a worker.  For distributed computing, seed numbers are generated for multiple workers by increasing 1, e.g. seedNum = 123 &amp; 10 workers, <code>setSeed</code> generates seeds from 123 to 132 and assigns to corresponding workers (processes). </li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; using Distributed
julia&gt; addprocs(10)
julia&gt; @everywhere using flxQTL
julia&gt; setSeed(123)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/FlxQTL.jl/blob/3f98e4000af8f88b3f5d817e824352aa3fbd0019/src/Miscellanea.jl#L19-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FlxQTL.Util.sortBycM" href="#FlxQTL.Util.sortBycM"><code>FlxQTL.Util.sortBycM</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">    sortBycM(Chr::Any,XX::Markers,cross::Int64,cM::Int64=2)</code></pre><p>Returns marker indices in Chromosome <code>Chr</code> and the corresponding genotype probabilities keeping only markers positioned in every <code>cM</code> centimorgans  for any genome scan to avoid singularity.</p><p><strong>Arguments</strong></p><ul><li><code>Chr</code> : A type of Any indicating a particular chromosome to sort markers out.</li><li><code>XX</code> : A type of <a href="#FlxQTL.Util.Markers"><code>Markers</code></a>.</li><li><code>cross</code> : An integer indicating the number of alleles or genotypes. Ex. 2 for RIF, 4 for four-way cross, 8 for HS mouse (allele probabilities), etc.</li><li><code>cM</code> : An integer of dropping criterion of markers. Default is 2, i.e. keeping only markers in every 2 cM, or dropping markers within 2cM between 2 markers.</li></ul><p>See also <a href="#FlxQTL.Util.newMarkers"><code>newMarkers</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/FlxQTL.jl/blob/3f98e4000af8f88b3f5d817e824352aa3fbd0019/src/Miscellanea.jl#L265-L281">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../guide/analysis/">« QTL Analysis</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.15.0 on <span class="colophon-date" title="Wednesday 12 November 2025 02:16">Wednesday 12 November 2025</span>. Using Julia version 1.12.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
