<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>QTL Analysis · FlxQTL.jl</title><meta name="title" content="QTL Analysis · FlxQTL.jl"/><meta property="og:title" content="QTL Analysis · FlxQTL.jl"/><meta property="twitter:title" content="QTL Analysis · FlxQTL.jl"/><meta name="description" content="Documentation for FlxQTL.jl."/><meta property="og:description" content="Documentation for FlxQTL.jl."/><meta property="twitter:description" content="Documentation for FlxQTL.jl."/><meta property="og:url" content="https://senresearch.github.io/FlxQTL.jl/stable/guide/analysis/"/><meta property="twitter:url" content="https://senresearch.github.io/FlxQTL.jl/stable/guide/analysis/"/><link rel="canonical" href="https://senresearch.github.io/FlxQTL.jl/stable/guide/analysis/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">FlxQTL.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../tutorial/">Package Guide</a></li><li class="is-active"><a class="tocitem" href>QTL Analysis</a><ul class="internal"><li><a class="tocitem" href="#Input-data-file-format"><span>Input data file format</span></a></li><li><a class="tocitem" href="#Reading-the-data-files-and-processing-arrays"><span>Reading the data files and processing arrays</span></a></li><li><a class="tocitem" href="#Computing-a-genetic-relatedness-matrix-(GRM)-and-pre-computing-a-covariance-structure-for-a-random-matrix-(Kc)"><span>Computing a genetic relatedness matrix (GRM) and pre-computing a covariance structure for a random matrix (Kc)</span></a></li><li><a class="tocitem" href="#1D-genome-scan"><span>1D genome scan</span></a></li><li><a class="tocitem" href="#Generating-plots"><span>Generating plots</span></a></li><li><a class="tocitem" href="#Performing-a-permutation-test"><span>Performing a permutation test</span></a></li><li><a class="tocitem" href="#2D-genome-scan"><span>2D genome scan</span></a></li></ul></li><li><a class="tocitem" href="../../functions/">Types and Functions</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>QTL Analysis</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>QTL Analysis</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/senresearch/FlxQTL.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/senresearch/FlxQTL.jl/blob/master/docs/src/guide/analysis.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="QTL-analysis"><a class="docs-heading-anchor" href="#QTL-analysis">QTL analysis</a><a id="QTL-analysis-1"></a><a class="docs-heading-anchor-permalink" href="#QTL-analysis" title="Permalink"></a></h1><p>This section describes a step-by-step instruction for QTL analysis.</p><h2 id="Input-data-file-format"><a class="docs-heading-anchor" href="#Input-data-file-format">Input data file format</a><a id="Input-data-file-format-1"></a><a class="docs-heading-anchor-permalink" href="#Input-data-file-format" title="Permalink"></a></h2><p>The package <code>FlxQTL</code> does not require any particular data format.  Any file readable in Julia is fine, but the input should contain traits (or phenotypes), genotypes (or genotype probabilities), marker information on marker names, chromosomes, and marker positions.  All inputs are types of  Arrays in Julia and should have no missing values, i.e. imputation is required if missing values exist.</p><h2 id="Reading-the-data-files-and-processing-arrays"><a class="docs-heading-anchor" href="#Reading-the-data-files-and-processing-arrays">Reading the data files and processing arrays</a><a id="Reading-the-data-files-and-processing-arrays-1"></a><a class="docs-heading-anchor-permalink" href="#Reading-the-data-files-and-processing-arrays" title="Permalink"></a></h2><p>Use any Julia package able to read data files (<code>.txt</code>, <code>.csv</code>, etc.).  Julia&#39;s built-in module <code>DelimitedFiles</code> supports read, and write files.  Let&#39;s try using an example dataset in <code>FlxQTL</code>. It is plant data: Arabidopsis thaliana in the <code>data</code> folder.  Detailed description on the data can be  referred to <code>README</code> in the folder.</p><pre><code class="language-julia hljs">using DelimitedFiles

pheno = readdlm(&quot;data/Arabidopsis_fitness.csv&quot;,&#39;,&#39;;skipstart=1); # skip to read the first row (column names) to obtain a matrix only

geno = readdlm(&quot;data/Arabidopsis_genotypes.csv&quot;,&#39;,&#39;;skipstart=1); 

markerinfo = readdlm(&quot;data/Arabidopsis_markerinfo_1d.csv&quot;,&#39;,&#39;;skipstart=1);</code></pre><p>For efficient computation, the normalization of matrices is necessary.  The phenotype matrix labelled as <code>pheno</code> here composes of a wide range of values  from 1.774 to 34.133, so that it is better to narow the range of values in [0,1], [-1,1], or any narrower interval for easy computation.  Note that  the dimension of a phenotype matrix should be <code>the number of traits x the number of individuals</code>, i.e. <code>m x n</code>.</p><pre><code class="language-julia hljs">using Statistics, StatsBase
Y=convert(Array{Float64,2},pheno&#39;); #convert from transposed one to a Float64 matrix
Ystd=(Y.-mean(Y,dims=2))./std(Y,dims=2); # sitewise normalization</code></pre><p>!!! Note</p><ul><li>If the data are skewed or have outliers, simple standadization may not resolve them.  You may use a <code>Y_huber</code> function to rescale the data to be less sensitve to outliers.</li></ul><p>In the genotype data, <code>1</code>, <code>2</code> indicate Italian, Swedish parents, respectively. You can rescale the genotypes for efficiency. </p><pre><code class="language-julia hljs">geno[geno.==1.0].=0.0;geno[geno.==2.0].=1.0; # or can do geno[geno.==1.0].=-1.0 for only genome scan</code></pre><p>For genome scan, we need restructure the standardized genotype matrix combined with marker information.  Note that the genome scan in <code>FlxQTL</code> is  implemented by CPU parallelization, so we need to add workers (or processes) before the genome scan.  Depending on the computer CPU, one can add as many  processes as possible. If your computer has 16 cores, then you can add 15 or little more.  Note that you need to type <code>@everywhere</code> followed by <code>using PackageName</code> for parallel computing.  The dimension of a genotype (probability) matrix should be  <code>the number of markers x the number of individuals</code>, i.e. <code>p x n</code>.</p><pre><code class="language-julia hljs">using Distributed
addprocs(4) 
@everywhere using FlxQTL 
XX=Markers(markerinfo[:,1],markerinfo[:,2],markerinfo[:,3],geno&#39;) # marker names, chromosomes, marker positions, genotypes</code></pre><p>&lt;!– - <strong>Julia tip</strong>: Whenever you reload a package, i.e. <code>using FlxQTL</code>, you should re-enter <code>XX=FlxQTL.Markers(markerinfo[:,1],markerinfo[:,2],markerinfo[:,3],geno&#39;)</code> to fresh the struct of array.  If not, your genome scan throws an error.  You should also do with another struct of array in a submodule <code>QTLplot</code>, <code>FlxQTL.layers</code>. –&gt;</p><p>Optionally, one can generate a trait covariate matrix (Z).  The first column indicates overall mean between the two regions, and  the second implies site difference: <code>-1</code> for Italy, and <code>1</code> for Sweden.</p><pre><code class="language-julia hljs">Z=hcat(ones(6),vcat(-ones(3),ones(3)))
m,q = size(Z) # check the dimension</code></pre><h2 id="Computing-a-genetic-relatedness-matrix-(GRM)-and-pre-computing-a-covariance-structure-for-a-random-matrix-(Kc)"><a class="docs-heading-anchor" href="#Computing-a-genetic-relatedness-matrix-(GRM)-and-pre-computing-a-covariance-structure-for-a-random-matrix-(Kc)">Computing a genetic relatedness matrix (GRM) and pre-computing a covariance structure for a random matrix (Kc)</a><a id="Computing-a-genetic-relatedness-matrix-(GRM)-and-pre-computing-a-covariance-structure-for-a-random-matrix-(Kc)-1"></a><a class="docs-heading-anchor-permalink" href="#Computing-a-genetic-relatedness-matrix-(GRM)-and-pre-computing-a-covariance-structure-for-a-random-matrix-(Kc)" title="Permalink"></a></h2><p>The submodule <code>GRM</code> contains functions for computing kinship matrices, <code>kinshipMan</code>, <code>kinship4way</code>, <code>kinshipLin</code>, <code>kinshipCtr</code>, and computing  3D array of kinship matrices for LOCO (Leave One Chromosome Out) with a shrinkage method for nonpositive definiteness,  <code>shrinkg</code>, <code>shrinkgLoco</code>, <code>kinshipLoco</code>.   Note that the shrinkage option is only used for <code>kinshipMan</code>, <code>kinship4way</code>.</p><p>For the Arabidopsis genotype data, we will use a genetic relatedness matrix using manhattan distance measure, <code>kinshipMan</code> with a shrinkage with  the LOCO option.</p><pre><code class="language-julia hljs">Kg = shrinkgLoco(kinshipMan,10,XX)</code></pre><p>For no LOCO option with shrinkage,</p><pre><code class="language-julia hljs">K = shrinkg(kinshipMan,10,XX.X)</code></pre><p>For computational efficiency, a <code>getKc</code> function pre-computes a covariance structured matrix for the random term, i.e., <code>Kc</code> in <code>\\tau^2 Kc \\approx \\Sigma_1.</code>   One can separately pre-compute <code>Kc</code> and run <code>geneScan</code> or just run <code>gene1Scan</code>, in which <code>getKc</code> precomputes <code>Kc.</code>  </p><pre><code class="language-julia hljs">using LinearAlgebra
K1= getKc(Ystd;Z=Z);
K1.Kc </code></pre><h2 id="1D-genome-scan"><a class="docs-heading-anchor" href="#1D-genome-scan">1D genome scan</a><a id="1D-genome-scan-1"></a><a class="docs-heading-anchor-permalink" href="#1D-genome-scan" title="Permalink"></a></h2><p>Once all input matrices are ready, we need to proceed the eigen-decomposition to two relatedness matrices.  For a precomputed random covariance structured matrix, and a kinship with LOCO, you can do eigen-decomposition simultaneously.  </p><pre><code class="language-julia hljs">Tg,Λg,Tc,λc = K2Eig(Kg,K1.Kc,true); # the last argument: LOCO::Bool = false (default)</code></pre><p>Or,</p><pre><code class="language-julia hljs">Tg,λg = K2eig(Kg, true) # for eigen decomposition to one kinship with LOCO</code></pre><p>For eigen decomposition to one kinship with no LOCO option,</p><pre><code class="language-julia hljs">T,λ = K2eig(K)</code></pre><p>Now start with 1D genome scan with (or without) LOCO including <code>Z</code> or not.   For the genome scan with LOCO including <code>Z</code>, </p><pre><code class="language-julia hljs">LODs,B,est0 = geneScan(1,Tg,Tc,Λg,λc,Ystd,XX,Z,true); # FlxQTL for including Z (trait covariates)</code></pre><p>For the genome scan with LOCO excluding <code>Z</code>, i.e. an identity matrix, we have two options: a FlxQTL model and a conventional MLMM </p><pre><code class="language-julia hljs">LODs,B,est0 = geneScan(1,Tg,Tc,Λg,λc,Ystd,XX,true); # FlxQTL for Z=I 

LODs,B,est0 = geneScan(1,Tg,Tc,Λg,λc,Ystd,XX,diagm(ones(m)),true); # or equivalently, FlxQTL for Z=I 

lods,b,Est0 = geneScan(1,Tg,Λg,Ystd,XX,true); # MLMM</code></pre><p>Note that the first argument in <code>geneScan</code> is <code>cross::Int64</code>, which indicates a type of genotype or genotype probability.  For instance, if you use a  genotype matrix whose entry is one of 0,1,2, type <code>1</code>. If you use genotype probability matrices, depending on the number of alleles or genotypes in a marker, one can type the corresponding number. i.e. <code>4-way cross: 4</code>, <code>HS DO mouse: 8 for alleles, 32 for genotypes</code>, etc.  Now the new verson of FlxQTL is operated by penalized log-likelihood function using <code>Prior</code> with <code>df_prior</code> for a error term, <span>$\\Sigma$</span>, distributed by Inverse-Wishart distribution for numerial stability.  One can also adjust them in the Keyword arguments.  The default positive definite scale matrix is a large scaled matrix (<code>cov(Y,dims=2)*5</code>).  We recommend using a large scale matrix for computational efficiency.</p><p>For no LOCO option,</p><pre><code class="language-julia hljs">LOD,B1,est00 = geneScan(1,T,Tc,λ,λc,Ystd,XX,Z);

LOD,B1,est00 = geneScan(1,T,Tc,λ,λc,Ystd,XX); # Z=I

LOD,B1,est00 = geneScan(1,T,Tc,λ,λc,Ystd,XX,diagm(ones(m))); #Z=I

lod,b1,Est00 = geneScan(1,T,λ,Ystd,XX); # MLMM</code></pre><p>One can also use <code>gene1Scan</code>, so that you do not have to precompute <code>Kc.</code></p><pre><code class="language-julia hljs">
LODs,B,est0 = gene1Scan(1,Tg,Λg,Ystd,XX,Z,true); 

LODs,B,est0 = gene1Scan(1,Tg,Λg,Ystd,XX,true); # for Z=I

LODs,B,est0 = gene1Scan(1,Tg,Λg,Ystd,XX,diagm(ones(m)),true); # equivalently, for Z=I</code></pre><p>For no LOCO option,</p><pre><code class="language-julia hljs">LOD,B1,est00 = gene1Scan(1,T,λ,Ystd,XX,Z);

</code></pre><p>The function <code>geneScan</code> has three arguments: <code>LOD scores (LODs)</code>, <code>effects matrix under H1 (B)</code>, and <code>parameter estimates under H0 (est0)</code>, which  is an <code>Array{Any,1}</code>.  If you want to see null parameter esitmate in chromosome 1 for LOCO option, type <code>est0[1].B</code>, <code>est0[1].loglik</code>, <code>est0[1].τ2</code>,  <code>est0[1].Σ</code>.    In particular, you can extract values from each matrix in <code>B</code> (3D array of matrices) to generate an effects plot. To print an effect size matrix for the  third marker, type <code>B[:,:,3]</code>, where the last dimension is the order of a marker in the genotype (probability) data.</p><h2 id="Generating-plots"><a class="docs-heading-anchor" href="#Generating-plots">Generating plots</a><a id="Generating-plots-1"></a><a class="docs-heading-anchor-permalink" href="#Generating-plots" title="Permalink"></a></h2><p>The <code>QTLplot</code> module is currently unavailable but plotting functions will be replaced with <a href="https://github.com/senresearch/BigRiverQTLPlots.jl">BigRiverQTLPlots.jl</a> soon.</p><p><img src="../images/arab-lod.png" alt="arabidopsis"/></p><h2 id="Performing-a-permutation-test"><a class="docs-heading-anchor" href="#Performing-a-permutation-test">Performing a permutation test</a><a id="Performing-a-permutation-test-1"></a><a class="docs-heading-anchor-permalink" href="#Performing-a-permutation-test" title="Permalink"></a></h2><p>Since the statistical inference for <code>FlxQTL</code> relies on LOD scores, the function <code>permTest</code> finds thresholds for a type I error.   The first argument is <code>nperm::Int64</code> to set the number of permutations for the test.  For keyword arguments, <code>pval=[0.05 0.01]</code> is default to get thresholds of <code>type I error rates (α)</code>, and the identity matrix, i.e. <code>Z=diagm(ones(m))</code> is default.  Note that permutation test is implemented by no LOCO option since the difference between no LOCO and LOCO options for many simulations would be very minor.</p><pre><code class="language-julia hljs">maxLODs, H1par_perm, cutoff = permTest(1000,1,K,Kc,Ystd,XX;Z=Z,pval=[0.05]) # cutoff at 5 %

maxlods, H1par_perm1, cutoff1 = permTest(1000,1,K,Ystd,XX;pval=[0.05])  # for MLMM
</code></pre><h2 id="2D-genome-scan"><a class="docs-heading-anchor" href="#2D-genome-scan">2D genome scan</a><a id="2D-genome-scan-1"></a><a class="docs-heading-anchor-permalink" href="#2D-genome-scan" title="Permalink"></a></h2><p>A <code>gene2Scan</code> function has two options just as <code>geneScan</code> and <code>gene1Scan</code> functions.  Note that one needs a coarser genotype (probability) matrix since  the distance between any two markers in a chromosome is very close each other, often yielding a numerical error during the operation.  This will be worse when the conversional MLMM is chosen to implement.     The provided data for 2D scan are generated by the <a href="https://cran.r-project.org/web/packages/qtl/qtl.pdf">R/qtl</a> library with a <code>sim.geno</code> function by picking one of the simulated data sets, where <code>step=5</code> and <code>draws=16</code> were set.</p><pre><code class="language-julia hljs">geno_2d = readdlm(&quot;data/Arabidopsis_genotypes_2d.csv&quot;,&#39;,&#39;;skipstart=1); 

markerinfo_2d = readdlm(&quot;data/Arabidopsis_markerinfo_2d.csv&quot;,&#39;,&#39;;skipstart=1);

geno_2d[geno_2d.==1.0].=0.0;geno_2d[geno_2d.==2.0].=1.0; # or can do geno_2d[geno_2d.==1.0].=-1.0 for only genome scan

X2=Markers(markerinfo_2d[:,1],markerinfo_2d[:,2],markerinfo_2d[:,3],geno_2d) # marker names, 

LOD_2d,B2,est02 = gene2Scan(1,T,Tc,Λg,λc,Ystd,XX,Z,true); 

LOD_2d,B2,est02 = gene2Scan(1,T,Tc,Λg,λc,Ystd,XX,diagm(one(m)),true);  # for Z=I

LOD_2d,B2,est02 = gene2Scan(1,Tg,Λg,Ystd,XX,Z,true); # precomputing Kc inside the function

lod_2d,b2,Est02 = gene2Scan(1,Tg,Λg,Ystd,XX,true) # MLMM</code></pre><p>Or one can do with no LOCO as explained as in aforementioned 1D genome scan.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tutorial/">« Package Guide</a><a class="docs-footer-nextpage" href="../../functions/">Types and Functions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.11.4 on <span class="colophon-date" title="Monday 19 May 2025 05:06">Monday 19 May 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
